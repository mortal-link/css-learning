import type { Section, TutorialBlock } from '../modules';
import type { GlossaryEntry } from '../glossary';

export const sections: Section[] = [
  {
    id: 'selector-overview',
    number: '1',
    title: { zh: '选择器概述', en: 'Selector Overview' },
    specId: 'pattern-matching',
    summary: { zh: '选择器是 CSS 的核心机制——它决定了样式规则会应用到文档中的哪些元素上。一个选择器可以简单到只匹配一个元素类型（如 p），也可以复杂到组合多个条件精确定位某个特定上下文中的元素。理解选择器的分类（简单选择器、复合选择器、复杂选择器）和组合方式（选择器列表），是掌握 CSS 的第一步。浏览器从右向左匹配选择器，这个方向影响着选择器的性能表现。', en: 'Selectors are the core mechanism of CSS—they determine which elements in a document style rules apply to. A selector can be as simple as matching a single element type (like p), or as complex as combining multiple conditions to precisely target an element in a specific context. Understanding selector categories (simple, compound, complex selectors) and combination methods (selector lists) is the first step to mastering CSS. Browsers match selectors from right to left, which affects selector performance.' },
    keyPoints: [
      '选择器的作用：将样式规则关联到文档树中的一个或多个元素',
      '选择器列表（逗号分隔）：h1, h2, h3 表示三个选择器共享同一组声明',
      '简单选择器（simple selector）：类型、通配符、类、ID、属性、伪类等单一条件',
      '复合选择器（compound selector）：多个简单选择器紧密连接，如 div.card#main',
      '复杂选择器（complex selector）：用组合符（空格、>、+、~）连接多个复合选择器',
      '浏览器从右向左匹配：div p 先找所有 p，再检查祖先是否有 div',
      '无效选择器会导致整个规则集被忽略（CSS3 之前），但 :is()/:where() 具有宽容性',
    ],
    tutorial: [
      { type: 'heading', text: '选择器：CSS 的寻址系统' },
      { type: 'paragraph', text: '选择器是 CSS 的**寻址系统**——它决定样式规则应用到哪些元素上。没有选择器，CSS 无法知道要样式化什么。选择器可以简单到只匹配一个元素类型（`p`），也可以复杂到组合多个条件精确定位特定上下文中的元素（`article > h2.highlight:first-child`）。理解选择器的分类和组合方式，是掌握 CSS 的第一步。' },
      { type: 'code', code: '/* 基础选择器 */\np { color: blue; }                    /* 匹配所有 <p> 元素 */\n.card { border: 1px solid gray; }    /* 匹配所有 class="card" 的元素 */\n#main { width: 960px; }              /* 匹配 id="main" 的元素 */', lang: 'css', caption: '三种最常见的选择器' },
      { type: 'heading', text: '选择器列表：共享样式' },
      { type: 'paragraph', text: '当多个选择器需要应用相同样式时，可以用逗号分隔它们组成**选择器列表**（selector list）。浏览器会将列表拆分为独立的规则——`h1, h2, h3 { color: navy; }` 等价于三条独立规则。' },
      { type: 'example', title: '选择器列表', code: 'h1, h2, h3 {\n  color: navy;\n  font-family: Georgia;\n}', lang: 'css', explanation: '所有 h1、h2、h3 元素都会应用这两条声明。这比写三条独立规则更简洁。' },
      { type: 'warning', text: '如果列表中**任何一个选择器无效**，整个规则集会被忽略（CSS3 之前的行为）。例如 `h1, h2, :unknown { color: red; }` 中，`:unknown` 无效导致整条规则失效。CSS4 的 `:is()` 和 `:where()` 提供了宽容性解决方案。' },
      { type: 'heading', text: '选择器的三种复杂度级别' },
      { type: 'list', items: [
        '**简单选择器**（simple selector）：单一条件，如 `p`（类型）、`.card`（类）、`#main`（ID）、`[type="text"]`（属性）、`:hover`（伪类）',
        '**复合选择器**（compound selector）：多个简单选择器紧密连接（无空格），如 `div.card#main`——匹配同时满足所有条件的元素',
        '**复杂选择器**（complex selector）：用组合符（空格、`>`、`+`、`~`）连接多个复合选择器，描述元素间关系，如 `div > p.intro`'
      ] },
      { type: 'code', code: '/* 简单选择器 */\np { }                /* 类型选择器 */\n.card { }            /* 类选择器 */\n#main { }            /* ID 选择器 */\n\n/* 复合选择器（无空格连接）*/\ndiv.card { }         /* div 且 class="card" */\np#intro.highlight { }/* p 且 id="intro" 且 class="highlight" */\n\n/* 复杂选择器（用组合符连接）*/\ndiv p { }            /* div 的后代 p */\ndiv > p { }          /* div 的直接子元素 p */\nh1 + p { }           /* h1 后的相邻 p */', lang: 'css', caption: '三种选择器复杂度' },
      { type: 'heading', text: '浏览器的匹配方向：从右向左' },
      { type: 'paragraph', text: '浏览器匹配选择器时**从右向左**（right-to-left）进行。对于 `div p.intro`，浏览器先找到所有 `class="intro"` 的 `<p>`（关键选择器），然后逐个检查祖先中是否有 `<div>`。这个方向影响性能——右侧选择器过于宽泛（如 `* { }`）会导致大量匹配尝试。' },
      { type: 'example', title: '匹配过程示例', code: '/* 选择器 */\ndiv p.intro { color: red; }\n\n<!-- HTML -->\n<div>\n  <p class="intro">匹配 ✓</p>\n  <section>\n    <p class="intro">匹配 ✓（祖先中有 div）</p>\n  </section>\n</div>\n<p class="intro">不匹配 ✗（祖先中无 div）</p>', lang: 'html', explanation: '浏览器先找所有 `.intro` 的 `p`，再检查每个元素的祖先链中是否有 `div`。' },
      { type: 'heading', text: '无效选择器的处理' },
      { type: 'paragraph', text: '当浏览器遇到无法解析的选择器（如未知伪类 `:future-feature`）时，会忽略整个规则集。这是 CSS 的前向兼容机制——新特性不会破坏旧浏览器，只是不生效。CSS4 的 `:is()` 和 `:where()` 引入了**宽容性**（forgiving）：列表中某个选择器无效不影响其他选择器。' },
      { type: 'code', code: '/* 传统行为（整个规则失效）*/\nh1, h2, :unknown {\n  color: red; /* 整条规则被忽略 */\n}\n\n/* 宽容性解决方案（CSS4）*/\n:is(h1, h2, :unknown) {\n  color: red; /* h1 和 h2 仍然生效 */\n}', lang: 'css', caption: ':is() 的宽容性' },
      { type: 'tip', text: '选择器列表是"或"逻辑（`h1, h2` = h1 **或** h2），复合选择器是"与"逻辑（`p.intro` = p **且** .intro）。区分这两种逻辑能帮助你写出更精确的选择器。' },
    ] as TutorialBlock[],
  },
  {
    id: 'simple-selectors',
    number: '2',
    title: { zh: '简单选择器', en: 'Simple Selectors' },
    specId: 'type-selectors',
    summary: { zh: '简单选择器是选择器系统的基石。类型选择器（h1, div, p）匹配特定元素名；通配符（*）匹配所有元素；类选择器（.class）和 ID 选择器（#id）匹配 HTML 属性；属性选择器提供更灵活的属性匹配能力，从精确匹配到子串匹配。这些选择器可以单独使用，也可以组合成复合选择器实现更精确的匹配。', en: 'Simple selectors are the foundation of the selector system. Type selectors (h1, div, p) match specific element names; the universal selector (*) matches all elements; class selectors (.class) and ID selectors (#id) match HTML attributes; attribute selectors provide flexible attribute matching from exact to substring matches. These selectors can be used alone or combined into compound selectors for more precise matching.' },
    keyPoints: [
      '类型选择器（type selector）：h1、div、p 等，匹配元素名（大小写不敏感）',
      '通配符选择器（universal selector）：* 匹配所有元素，常用于重置样式',
      '类选择器（class selector）：.card 匹配 class="card"，一个元素可以有多个类',
      'ID 选择器（id selector）：#main 匹配 id="main"，ID 在文档中应该唯一',
      '属性选择器：[attr] 存在性、[attr=value] 精确匹配、[attr~=value] 词列表匹配',
      '属性选择器扩展（CSS3）：[attr|=value] 连字符匹配、[attr^=value] 前缀、[attr$=value] 后缀、[attr*=value] 子串',
      '属性选择器可以带 i 标志实现大小写不敏感匹配：[attr=value i]',
    ],
    tutorial: [
      { type: 'heading', text: '类型选择器：按元素名匹配' },
      { type: 'paragraph', text: '**类型选择器**（type selector）匹配特定的元素名，如 `h1`、`div`、`p`、`article`。这是最基础的选择器——直接写元素名即可。类型选择器在 HTML 中是大小写不敏感的（`P` 和 `p` 等价），但在 XML 中区分大小写。' },
      { type: 'code', code: '/* 类型选择器 */\nh1 { font-size: 2em; }        /* 匹配所有 <h1> */\np { line-height: 1.6; }       /* 匹配所有 <p> */\narticle { max-width: 800px; } /* 匹配所有 <article> */', lang: 'css', caption: '按元素名匹配' },
      { type: 'tip', text: '类型选择器非常适合设置元素的默认样式——例如为所有段落设置行高、为所有链接设置颜色。但要注意它的特异性较低，容易被类选择器覆盖。' },
      { type: 'heading', text: '通配符选择器：匹配一切' },
      { type: 'paragraph', text: '**通配符选择器**（universal selector）用星号 `*` 表示，匹配**所有元素**。常用于 CSS 重置（如清除默认 margin/padding）或应用全局样式（如 box-sizing）。' },
      { type: 'example', title: '通配符重置样式', code: '* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}', lang: 'css', explanation: '所有元素的 margin 和 padding 被重置为 0，box-sizing 被设为 border-box。' },
      { type: 'warning', text: '通配符选择器会匹配**每一个**元素，包括 `<html>`、`<body>`、`<head>`。性能影响通常可忽略（现代浏览器优化很好），但不要用它设置复杂属性。' },
      { type: 'heading', text: '类选择器：可复用的样式标签' },
      { type: 'paragraph', text: '**类选择器**（class selector）以点号 `.` 开头，匹配 `class` 属性值。类是 CSS 中最灵活的匹配方式——一个元素可以有多个类（空格分隔），一个类可以应用于多个元素。' },
      { type: 'code', code: '/* 类选择器 */\n.card { border: 1px solid #ddd; }\n.highlight { background: yellow; }\n.text-center { text-align: center; }\n\n<!-- HTML -->\n<div class="card">卡片</div>\n<div class="card highlight">高亮卡片</div>\n<p class="text-center highlight">居中且高亮的段落</p>', lang: 'html', caption: '类可以自由组合' },
      { type: 'tip', text: '类选择器是 CSS 中最常用的选择器——它比类型选择器更精确（不会影响所有同类型元素），比 ID 选择器更灵活（可复用）。BEM 等命名方法论都基于类选择器构建。' },
      { type: 'heading', text: 'ID 选择器：唯一标识' },
      { type: 'paragraph', text: '**ID 选择器**（id selector）以井号 `#` 开头，匹配 `id` 属性值。HTML 规范要求 ID 在文档中**唯一**——每个 ID 值只能出现一次。ID 选择器的特异性很高（仅次于行内样式），容易导致样式难以覆盖。' },
      { type: 'code', code: '/* ID 选择器 */\n#header { height: 60px; }\n#main { max-width: 1200px; }\n#footer { background: #333; }\n\n<!-- HTML -->\n<header id="header">头部</header>\n<main id="main">主内容</main>\n<footer id="footer">页脚</footer>', lang: 'html', caption: 'ID 用于唯一元素' },
      { type: 'warning', text: '现代最佳实践：**尽量避免使用 ID 选择器**。ID 的高特异性会让样式难以覆盖，破坏可维护性。除了锚点跳转和 JavaScript 访问，ID 在 CSS 中应该很少使用。' },
      { type: 'heading', text: '属性选择器：灵活的匹配模式' },
      { type: 'paragraph', text: '**属性选择器**（attribute selector）用方括号 `[]` 包裹，可以根据元素的属性和属性值进行匹配。CSS2 提供了基础匹配，CSS3 大幅扩展了匹配模式（前缀、后缀、子串）。' },
      { type: 'code', code: '/* 属性选择器（CSS2）*/\n[disabled] { opacity: 0.5; }           /* 存在 disabled 属性 */\n[type="text"] { border: 1px solid; }   /* type 精确等于 "text" */\n[class~="active"] { font-weight: bold; }/* class 包含词 "active" */\n\n/* 属性选择器（CSS3）*/\n[href^="https"] { color: green; }      /* href 以 "https" 开头 */\n[href$=".pdf"] { color: red; }         /* href 以 ".pdf" 结尾 */\n[class*="btn"] { padding: 0.5em 1em; } /* class 包含子串 "btn" */\n[lang|="en"] { quotes: """ """; }      /* lang 是 "en" 或 "en-*" */', lang: 'css', caption: '属性选择器的六种模式' },
      { type: 'example', title: '实用场景：匹配外部链接', code: '/* 为外部链接添加图标 */\na[href^="http"]:not([href^="https://mysite.com"]) {\n  padding-right: 1em;\n  background: url(external.svg) right center no-repeat;\n}', lang: 'css', explanation: '匹配以 http 开头且不是本站域名的链接，自动添加外部链接图标。' },
      { type: 'heading', text: '大小写不敏感标志' },
      { type: 'paragraph', text: 'CSS3 允许在属性选择器末尾添加 `i` 标志，实现**大小写不敏感**匹配。这对匹配用户输入或不规范的 HTML 非常有用。' },
      { type: 'code', code: '/* 大小写敏感（默认）*/\n[type="text"] { }       /* 只匹配 type="text"，不匹配 type="TEXT" */\n\n/* 大小写不敏感 */\n[type="text" i] { }    /* 匹配 type="text"、type="TEXT"、type="Text" */\n\n/* 实用示例：匹配各种拼写 */\n[data-state="active" i] { }  /* 匹配 active、ACTIVE、Active */', lang: 'css', caption: 'i 标志实现大小写不敏感' },
      { type: 'list', items: [
        '类型选择器匹配元素名，适合设置元素的默认样式',
        '通配符 `*` 匹配所有元素，常用于全局重置',
        '类选择器最灵活，可复用、可组合，是 CSS 的主力选择器',
        'ID 选择器特异性过高，现代开发中应尽量避免',
        '属性选择器提供六种匹配模式：存在性、精确、词列表、连字符、前缀、后缀、子串',
        '属性选择器的 `i` 标志实现大小写不敏感匹配'
      ] },
      { type: 'tip', text: '简单选择器可以自由组合成复合选择器——`div.card[data-state="active"]` 匹配同时满足三个条件的元素。' },
    ] as TutorialBlock[],
  },
  {
    id: 'combinators',
    number: '3',
    title: { zh: '组合器', en: 'Combinators' },
    specId: 'descendant-selectors',
    summary: { zh: '组合器（combinator）用于连接多个选择器，描述元素之间的关系。CSS 提供了四种组合器：后代（空格）、子代（>）、相邻兄弟（+）、通用兄弟（~）。这些组合器让我们能够根据元素在文档树中的位置关系来匹配元素。理解组合器的语义和浏览器的匹配方向（从右向左），对写出高效的选择器至关重要。', en: 'Combinators connect multiple selectors to describe relationships between elements. CSS provides four combinators: descendant (space), child (>), adjacent sibling (+), and general sibling (~). These combinators allow matching elements based on their positional relationships in the document tree. Understanding combinator semantics and browser matching direction (right to left) is crucial for writing efficient selectors.' },
    keyPoints: [
      '后代选择器（descendant combinator）：div p 匹配 div 内的所有 p（任意深度）',
      '子代选择器（child combinator）：div > p 只匹配 div 的直接子元素 p',
      '相邻兄弟选择器（adjacent sibling combinator）：h1 + p 匹配紧跟在 h1 后的第一个 p',
      '通用兄弟选择器（general sibling combinator）：h1 ~ p 匹配 h1 后所有同级的 p（CSS3）',
      '浏览器从右向左匹配：div > p.intro 先找所有 .intro 的 p，再检查父元素是否是 div',
      '组合器两侧的空白会被标准化，div>p 和 div > p 等价',
      '避免过深的后代选择器（如 div div div p）——匹配范围过广，性能较差',
    ],
    tutorial: [
      { type: 'heading', text: '组合器：描述元素间的关系' },
      { type: 'paragraph', text: '**组合器**（combinator）用于连接多个选择器，描述元素在文档树中的位置关系。CSS 提供了四种组合器：**后代**（空格）、**子代**（`>`）、**相邻兄弟**（`+`）、**通用兄弟**（`~`）。理解这些组合器能让你精确定位特定上下文中的元素，而不需要添加额外的类名。' },
      { type: 'heading', text: '后代选择器：任意深度匹配' },
      { type: 'paragraph', text: '**后代选择器**（descendant combinator）用空格表示，匹配某元素**内部任意深度**的后代元素。`div p` 匹配 `<div>` 内的所有 `<p>`，无论嵌套多深。' },
      { type: 'code', code: '/* 后代选择器 */\narticle p {\n  line-height: 1.8;\n}\n\n<!-- HTML -->\n<article>\n  <p>匹配 ✓（直接子元素）</p>\n  <section>\n    <p>匹配 ✓（孙元素，任意深度）</p>\n    <div>\n      <p>匹配 ✓（曾孙元素）</p>\n    </div>\n  </section>\n</article>\n<p>不匹配 ✗（不在 article 内）</p>', lang: 'html', caption: '后代选择器匹配任意深度' },
      { type: 'tip', text: '后代选择器是最常用的组合器——它让你可以为特定区域的元素设置样式，而不影响页面其他部分。例如 `nav a` 只样式化导航栏中的链接。' },
      { type: 'heading', text: '子代选择器：只匹配直接子元素' },
      { type: 'paragraph', text: '**子代选择器**（child combinator）用 `>` 表示，只匹配**直接子元素**（parent-child 关系），不匹配更深层的后代。`div > p` 只匹配 `<div>` 的直接子元素 `<p>`，不匹配孙元素。' },
      { type: 'code', code: '/* 子代选择器 */\nul > li {\n  list-style-type: disc;\n}\n\n<!-- HTML -->\n<ul>\n  <li>匹配 ✓（直接子元素）</li>\n  <li>\n    嵌套列表\n    <ul>\n      <li>不匹配 ✗（孙元素，非直接子元素）</li>\n    </ul>\n  </li>\n</ul>', lang: 'html', caption: '子代选择器只匹配直接子元素' },
      { type: 'example', title: '实用场景：避免样式泄漏', code: '/* 只样式化顶层导航项，不影响子菜单 */\nnav > ul > li {\n  display: inline-block;\n}\n\n/* 如果用后代选择器，子菜单的 li 也会受影响 */\nnav li {  /* ✗ 不好：会匹配所有嵌套 li */\n  display: inline-block;\n}', lang: 'css', explanation: '子代选择器防止样式泄漏到嵌套结构。' },
      { type: 'heading', text: '相邻兄弟选择器：紧跟的下一个元素' },
      { type: 'paragraph', text: '**相邻兄弟选择器**（adjacent sibling combinator）用 `+` 表示，匹配**紧跟在某元素后**的**第一个**同级元素。`h1 + p` 匹配紧跟在 `<h1>` 后的第一个 `<p>`，如果中间有其他元素则不匹配。' },
      { type: 'code', code: '/* 相邻兄弟选择器 */\nh1 + p {\n  font-size: 1.2em;  /* 标题后的第一段作为导语，字号稍大 */\n  color: #666;\n}\n\n<!-- HTML -->\n<h1>标题</h1>\n<p>匹配 ✓（紧跟 h1）</p>\n<p>不匹配 ✗（不是紧跟 h1 的第一个 p）</p>\n\n<h1>另一个标题</h1>\n<img src="photo.jpg">\n<p>不匹配 ✗（h1 后紧跟的是 img，不是 p）</p>', lang: 'html', caption: '相邻兄弟选择器只匹配紧跟的第一个' },
      { type: 'tip', text: '相邻兄弟选择器常用于为特定上下文的元素添加样式——例如标题后的第一段、按钮后的提示文本。' },
      { type: 'heading', text: '通用兄弟选择器：之后所有同级元素' },
      { type: 'paragraph', text: '**通用兄弟选择器**（general sibling combinator）用 `~` 表示，匹配某元素**之后所有**同级元素（CSS3 新增）。`h1 ~ p` 匹配 `<h1>` 后所有同级的 `<p>`，无论中间有无其他元素。' },
      { type: 'code', code: '/* 通用兄弟选择器 */\nh1 ~ p {\n  margin-left: 2em;\n}\n\n<!-- HTML -->\n<article>\n  <p>不匹配 ✗（在 h1 之前）</p>\n  <h1>标题</h1>\n  <p>匹配 ✓（h1 之后的 p）</p>\n  <img src="photo.jpg">\n  <p>匹配 ✓（h1 之后的 p，即使中间有 img）</p>\n  <section>\n    <p>不匹配 ✗（不是同级元素）</p>\n  </section>\n</article>', lang: 'html', caption: '通用兄弟选择器匹配之后所有同级元素' },
      { type: 'heading', text: '浏览器匹配方向：从右向左' },
      { type: 'paragraph', text: '浏览器匹配组合器选择器时**从右向左**进行。对于 `div > p.intro`，浏览器先找到所有 `class="intro"` 的 `<p>`（**关键选择器**），然后检查每个元素的父元素是否是 `<div>`。这个方向影响性能——右侧选择器过于宽泛会导致大量不必要的检查。' },
      { type: 'example', title: '性能对比', code: '/* ✓ 好：关键选择器较窄 */\n.sidebar .widget-title { }  /* 先找 .widget-title，再检查祖先 */\n\n/* ✗ 差：关键选择器过宽 */\ndiv div div p { }  /* 先找所有 p（可能很多），再检查三层 div 祖先 */', lang: 'css', explanation: '关键选择器（最右侧）越窄，初始匹配范围越小，性能越好。' },
      { type: 'warning', text: '避免过深的后代选择器（如 `html body div div div p`）——它们匹配范围过广、特异性过高、难以维护。通常 2-3 层已经足够。' },
      { type: 'heading', text: '空白标准化' },
      { type: 'paragraph', text: '组合器两侧的空白会被标准化——`div>p`、`div > p`、`div  >  p` 完全等价。为了可读性，推荐在组合器两侧加空格（除了后代选择器本身就是空格）。' },
      { type: 'code', code: '/* 这些选择器完全等价 */\ndiv>p { }\ndiv > p { }\ndiv  >  p { }\n\n/* 推荐：两侧加空格 */\ndiv > p { }    /* ✓ 可读性好 */\nh1 + p { }     /* ✓ */\nh1 ~ p { }     /* ✓ */', lang: 'css', caption: '空白会被标准化' },
      { type: 'list', items: [
        '**后代选择器**（空格）：匹配任意深度的后代元素',
        '**子代选择器**（`>`）：只匹配直接子元素',
        '**相邻兄弟选择器**（`+`）：匹配紧跟的第一个同级元素',
        '**通用兄弟选择器**（`~`）：匹配之后所有同级元素',
        '浏览器从右向左匹配，关键选择器（最右侧）决定初始匹配范围',
        '避免过深的后代选择器，通常 2-3 层已足够'
      ] },
      { type: 'tip', text: '组合器让你可以根据文档结构编写样式，而不需要为每个元素添加类名。但也要注意不要过度依赖——当选择器过长时，添加一个语义化的类名可能更好。' },
    ] as TutorialBlock[],
  },
  {
    id: 'pseudo-classes',
    number: '4',
    title: { zh: '伪类', en: 'Pseudo-classes' },
    specId: 'pseudo-elements',
    summary: { zh: '伪类（pseudo-class）用单冒号 : 表示，描述元素的特定状态或在文档树中的特定位置。CSS2 定义了链接伪类（:link、:visited）、用户交互伪类（:hover、:active、:focus）和结构伪类（:first-child）。CSS3 大幅扩展了结构伪类家族，引入了 :nth-child()、:nth-of-type() 等强大的模式匹配能力，以及表单状态伪类（:checked、:disabled、:valid 等）。', en: 'Pseudo-classes use a single colon (:) to describe specific states of elements or their positions in the document tree. CSS2 defined link pseudo-classes (:link, :visited), user interaction pseudo-classes (:hover, :active, :focus), and structural pseudo-classes (:first-child). CSS3 greatly expanded the structural pseudo-class family, introducing powerful pattern matching with :nth-child(), :nth-of-type(), and form state pseudo-classes (:checked, :disabled, :valid, etc.).' },
    keyPoints: [
      '链接伪类：:link（未访问）、:visited（已访问）、:any-link（任意链接，CSS4）',
      '用户交互伪类：:hover（鼠标悬停）、:active（激活）、:focus（焦点）',
      ':focus-visible（CSS4）：仅在键盘导航时显示焦点样式，避免鼠标点击时的焦点环',
      ':focus-within（CSS4）：元素自身或其后代获得焦点时匹配',
      '结构伪类：:first-child、:last-child、:only-child、:nth-child(an+b)、:nth-of-type(an+b)',
      ':nth-child(2n) 匹配偶数位子元素，:nth-child(odd) 匹配奇数位',
      '表单伪类（CSS3）：:checked、:disabled、:enabled、:required、:optional、:valid、:invalid、:in-range、:out-of-range',
      ':target（CSS3）：匹配 URL 片段标识符指向的元素',
    ],
    tutorial: [
      { type: 'heading', text: '伪类：状态与位置的选择器' },
      { type: 'paragraph', text: '**伪类**（pseudo-class）用单冒号 `:` 表示，描述元素的**状态**（如鼠标悬停、已选中、禁用）或在文档树中的**位置**（如第一个子元素、第 n 个子元素）。伪类让你可以根据动态状态或结构位置编写样式，而不需要 JavaScript 添加类名。' },
      { type: 'heading', text: '链接伪类：针对超链接' },
      { type: 'paragraph', text: '链接伪类专门用于 `<a>` 元素，描述链接的访问状态。CSS2 定义了 `:link`（未访问）和 `:visited`（已访问），CSS4 新增 `:any-link`（匹配任意链接，无论是否访问过）。' },
      { type: 'code', code: '/* 链接伪类 */\na:link { color: blue; }          /* 未访问的链接 */\na:visited { color: purple; }     /* 已访问的链接 */\na:any-link { text-decoration: underline; } /* 任意链接（CSS4）*/', lang: 'css', caption: '链接状态样式' },
      { type: 'warning', text: '`:visited` 的样式受到严格限制——出于隐私保护，只能修改颜色相关属性（`color`、`background-color`、`border-color`），不能修改布局或字体。浏览器不允许 JavaScript 读取 `:visited` 的计算样式。' },
      { type: 'heading', text: '用户交互伪类：响应用户操作' },
      { type: 'paragraph', text: '用户交互伪类描述元素与用户交互时的状态。`:hover`（鼠标悬停）、`:active`（激活/按下）、`:focus`（获得焦点）是最常用的三个。' },
      { type: 'code', code: '/* 用户交互伪类 */\nbutton:hover { background: #e0e0e0; }  /* 鼠标悬停 */\nbutton:active { background: #ccc; }    /* 按下时 */\ninput:focus { outline: 2px solid blue; } /* 获得焦点 */', lang: 'css', caption: '响应用户操作' },
      { type: 'tip', text: '伪类顺序很重要！链接样式推荐顺序：**L**o**V**e **HA**te（`:link` → `:visited` → `:hover` → `:active`）。因为 `:hover` 和 `:active` 特异性相同，后声明的会覆盖先声明的。' },
      { type: 'heading', text: ':focus-visible 和 :focus-within（CSS4）' },
      { type: 'paragraph', text: '`:focus-visible` 只在**键盘导航**时匹配焦点元素，避免鼠标点击时出现的焦点环（影响美观）。`:focus-within` 在元素**自身或其后代**获得焦点时匹配，用于高亮整个表单区域。' },
      { type: 'example', title: '键盘导航友好的焦点样式', code: '/* 传统方式（鼠标点击也显示焦点环）*/\nbutton:focus { outline: 2px solid blue; }\n\n/* 现代方式（仅键盘导航显示）*/\nbutton:focus { outline: none; }           /* 移除默认焦点环 */\nbutton:focus-visible { outline: 2px solid blue; } /* 键盘导航时显示 */', lang: 'css', explanation: '鼠标点击按钮不显示焦点环，Tab 键导航时显示。' },
      { type: 'code', code: '/* :focus-within 高亮表单区域 */\nform:focus-within {\n  background: #f0f8ff;\n  box-shadow: 0 0 10px rgba(0,0,255,0.3);\n}\n\n<!-- HTML -->\n<form>\n  <input type="text">  <!-- 当此输入框获得焦点时，整个 form 背景变色 -->\n</form>', lang: 'html', caption: ':focus-within 用于高亮容器' },
      { type: 'heading', text: '结构伪类：基于位置匹配' },
      { type: 'paragraph', text: '结构伪类根据元素在父元素中的**位置**或**类型**进行匹配。CSS2 只有 `:first-child`，CSS3 大幅扩展了这个家族，引入了强大的模式匹配能力。' },
      { type: 'code', code: '/* 基础结构伪类 */\np:first-child { font-weight: bold; }   /* 父元素的第一个子元素（且是 p）*/\np:last-child { margin-bottom: 0; }     /* 父元素的最后一个子元素（且是 p）*/\np:only-child { text-align: center; }   /* 父元素唯一的子元素（且是 p）*/\n\n/* :nth-child() 系列 */\nli:nth-child(2) { }      /* 第 2 个子元素（且是 li）*/\nli:nth-child(odd) { }    /* 奇数位子元素 = 1, 3, 5, ... */\nli:nth-child(even) { }   /* 偶数位子元素 = 2, 4, 6, ... */\nli:nth-child(2n) { }     /* 偶数位（2n = 2, 4, 6, ...）*/\nli:nth-child(2n+1) { }   /* 奇数位（2n+1 = 1, 3, 5, ...）*/\nli:nth-child(3n) { }     /* 每 3 个（3, 6, 9, ...）*/\nli:nth-child(3n+1) { }   /* 每 3 个，从第 1 个开始（1, 4, 7, ...）*/', lang: 'css', caption: '结构伪类' },
      { type: 'example', title: '斑马纹表格', code: '/* 偶数行背景色 */\ntable tr:nth-child(even) {\n  background: #f9f9f9;\n}', lang: 'css', explanation: '偶数行使用浅灰色背景，提升表格可读性。' },
      { type: 'heading', text: ':nth-child() vs :nth-of-type()' },
      { type: 'paragraph', text: '`:nth-child()` 计数**所有子元素**，`:nth-of-type()` 只计数**同类型元素**。这是常见混淆点。' },
      { type: 'code', code: '<!-- HTML -->\n<div>\n  <h2>标题</h2>        <!-- 第 1 个子元素，第 1 个 h2 -->\n  <p>段落 1</p>        <!-- 第 2 个子元素，第 1 个 p -->\n  <p>段落 2</p>        <!-- 第 3 个子元素，第 2 个 p -->\n</div>\n\n/* :nth-child() */\np:nth-child(2) { }  /* 匹配"段落 1"（第 2 个子元素，且是 p）*/\np:nth-child(1) { }  /* 不匹配（第 1 个子元素是 h2，不是 p）*/\n\n/* :nth-of-type() */\np:nth-of-type(1) { }  /* 匹配"段落 1"（第 1 个 p 类型元素）*/\np:nth-of-type(2) { }  /* 匹配"段落 2"（第 2 个 p 类型元素）*/', lang: 'css', caption: ':nth-child 计数所有，:nth-of-type 只计数同类型' },
      { type: 'tip', text: '`:nth-of-type()` 在混合内容中更可靠——你不需要关心其他类型的元素数量。' },
      { type: 'heading', text: '表单伪类：表单状态样式' },
      { type: 'paragraph', text: 'CSS3 引入了丰富的表单状态伪类，用于根据表单控件的状态（选中、禁用、有效、无效）应用样式。' },
      { type: 'code', code: '/* 表单伪类 */\ninput:checked { }      /* 选中的复选框/单选框 */\ninput:disabled { }     /* 禁用的输入框 */\ninput:enabled { }      /* 启用的输入框 */\ninput:required { }     /* 必填字段 */\ninput:optional { }     /* 可选字段 */\ninput:valid { }        /* 通过验证的输入 */\ninput:invalid { }      /* 未通过验证的输入 */\ninput:in-range { }     /* 值在范围内（type="number"）*/\ninput:out-of-range { } /* 值超出范围 */', lang: 'css', caption: '表单状态伪类' },
      { type: 'example', title: '实时表单验证反馈', code: '/* 有效输入：绿色边框 */\ninput:valid {\n  border-color: green;\n}\n\n/* 无效输入：红色边框 */\ninput:invalid {\n  border-color: red;\n}\n\n<!-- HTML -->\n<input type="email" required>  <!-- 浏览器自动验证邮箱格式 -->', lang: 'html', explanation: '输入有效邮箱时边框变绿，格式错误时变红。' },
      { type: 'heading', text: ':target 伪类' },
      { type: 'paragraph', text: '`:target` 匹配 URL **片段标识符**（`#id`）指向的元素。常用于实现纯 CSS 的标签页、手风琴等交互效果。' },
      { type: 'code', code: '/* :target 高亮当前锚点 */\nsection:target {\n  background: yellow;\n}\n\n<!-- HTML -->\n<a href="#intro">跳转到简介</a>\n<section id="intro">简介内容</section>  <!-- 点击链接后，URL 变为 #intro，此 section 匹配 :target -->', lang: 'html', caption: ':target 用于锚点高亮' },
      { type: 'list', items: [
        '链接伪类（`:link`、`:visited`）描述链接访问状态',
        '用户交互伪类（`:hover`、`:active`、`:focus`）响应用户操作',
        '`:focus-visible` 仅在键盘导航时显示焦点样式',
        '`:focus-within` 在元素或后代获得焦点时匹配',
        '结构伪类（`:first-child`、`:nth-child()`）根据位置匹配',
        '`:nth-child()` 计数所有子元素，`:nth-of-type()` 只计数同类型',
        '表单伪类（`:checked`、`:valid`、`:disabled`）描述表单状态',
        '`:target` 匹配 URL 片段标识符指向的元素'
      ] },
      { type: 'warning', text: '伪类与伪元素不同——伪类描述元素的**状态或位置**（单冒号 `:`），伪元素选择元素的**部分内容**或生成内容（双冒号 `::`）。下一节会详细讲解伪元素。' },
    ] as TutorialBlock[],
  },
  {
    id: 'logical-pseudo-classes',
    number: '5',
    title: { zh: '逻辑伪类', en: 'Logical Pseudo-classes' },
    specId: 'negation',
    summary: { zh: '逻辑伪类是 CSS 选择器系统的高级特性，它们接受选择器列表作为参数，提供逻辑运算能力。:not() 是否定伪类，排除匹配的元素；:is() 匹配列表中任一选择器；:where() 与 :is() 功能相同但特异性为 0；:has() 是"关系选择器"，能根据后代或兄弟元素的存在来匹配父元素。这些伪类极大地提升了选择器的表达能力，减少了重复代码。', en: 'Logical pseudo-classes are advanced features of the CSS selector system that accept selector lists as arguments, providing logical operations. :not() is the negation pseudo-class that excludes matching elements; :is() matches any selector in the list; :where() functions like :is() but with zero specificity; :has() is a "relational selector" that matches parent elements based on the presence of descendant or sibling elements. These pseudo-classes greatly enhance selector expressiveness and reduce code duplication.' },
    keyPoints: [
      ':not(selector) — 否定伪类：p:not(.intro) 匹配所有不含 .intro 类的 p',
      'CSS3 的 :not() 只接受简单选择器，CSS4 扩展为接受选择器列表：:not(.a, .b)',
      ':is(selector-list) — 匹配列表：:is(h1, h2, h3) 等价于 h1, h2, h3',
      ':is() 的特异性 = 参数中最高的特异性（而非 0）',
      ':is() 具有宽容性（forgiving）：列表中某个选择器无效不影响其他选择器',
      ':where(selector-list) — 与 :is() 功能相同，但特异性始终为 0',
      ':where() 常用于工具类库（如 Tailwind），确保用户样式能轻松覆盖',
      ':has(relative-selector) — 关系选择器（CSS4）：a:has(> img) 匹配包含直接子元素 img 的 a',
      ':has() 的特异性 = 参数中最高的特异性',
      ':has() 常被称为"父选择器"，但实际上是根据后代/兄弟关系匹配元素',
    ],
    tutorial: [
      { type: 'heading', text: '逻辑伪类：选择器的高级运算' },
      { type: 'paragraph', text: '**逻辑伪类**是 CSS 选择器系统的高级特性，它们接受选择器列表作为参数，提供**否定**、**匹配**、**关系**等逻辑运算能力。这些伪类极大地提升了选择器的表达能力，让你可以用更少的代码实现复杂的匹配逻辑。' },
      { type: 'heading', text: ':not() — 否定伪类' },
      { type: 'paragraph', text: '`:not()` 是**否定伪类**，匹配**不满足**参数选择器的元素。`p:not(.intro)` 匹配所有**不含** `.intro` 类的 `<p>` 元素。CSS3 的 `:not()` 只接受简单选择器（如 `.class`、`#id`），CSS4 扩展为接受选择器列表（如 `:not(.a, .b)`）。' },
      { type: 'code', code: '/* 否定伪类 */\np:not(.intro) { color: gray; }        /* 所有非 .intro 的 p */\ninput:not([type="submit"]) { }        /* 所有非提交按钮的输入 */\nli:not(:last-child) { margin-bottom: 1em; } /* 除最后一个外的所有 li */\n\n/* CSS4：选择器列表 */\n:not(.intro, .highlight, .warning) { } /* 不含这三个类的元素 */', lang: 'css', caption: '否定伪类排除匹配' },
      { type: 'example', title: '实用场景：排除特定元素', code: '/* 所有链接，除了导航栏中的 */\na:not(nav a) {\n  text-decoration: underline;\n}\n\n/* 等价于（但更简洁）*/\na { text-decoration: underline; }\nnav a { text-decoration: none; }', lang: 'css', explanation: '`:not()` 让排除逻辑更清晰。' },
      { type: 'warning', text: '`:not()` 不能嵌套——`:not(:not(.class))` 是无效的。如果需要复杂逻辑，使用 `:is()` 或 `:where()` 配合 `:not()` 实现。' },
      { type: 'heading', text: ':is() — 匹配列表伪类' },
      { type: 'paragraph', text: '`:is()` 匹配参数列表中**任意一个**选择器（OR 逻辑）。`:is(h1, h2, h3)` 等价于选择器列表 `h1, h2, h3`，但更强大——它可以用在复杂选择器的任意位置。' },
      { type: 'code', code: '/* 传统选择器列表 */\nh1, h2, h3 { color: navy; }\n\n/* :is() 等价写法 */\n:is(h1, h2, h3) { color: navy; }\n\n/* :is() 的真正威力：在复杂选择器中使用 */\narticle :is(h1, h2, h3) { }    /* article 内的 h1/h2/h3 */\n\n/* 传统写法需要重复三次 */\narticle h1,\narticle h2,\narticle h3 { }', lang: 'css', caption: ':is() 简化选择器列表' },
      { type: 'example', title: '多层嵌套简化', code: '/* 使用 :is() */\n:is(header, main, footer) :is(h1, h2) {\n  font-family: Georgia;\n}\n\n/* 传统写法需要 6 条规则 */\nheader h1, header h2,\nmain h1, main h2,\nfooter h1, footer h2 {\n  font-family: Georgia;\n}', lang: 'css', explanation: ':is() 将 6 条规则压缩为 1 条。' },
      { type: 'heading', text: ':is() 的特异性计算' },
      { type: 'paragraph', text: '`:is()` 的特异性**等于参数中最高的特异性**（而非 0）。这意味着 `:is(#id, .class)` 的特异性等于 `#id`（即使实际匹配的是 `.class`）。' },
      { type: 'code', code: '/* :is() 的特异性 = 参数中最高值 */\n:is(#main, .card) { }   /* 特异性 = (1,0,0)，等于 #main */\n:is(div, .card) { }     /* 特异性 = (0,1,0)，等于 .card */\n:is(div, p) { }         /* 特异性 = (0,0,1)，等于 div 或 p */', lang: 'css', caption: ':is() 特异性计算' },
      { type: 'tip', text: '`:is()` 具有**宽容性**（forgiving）——列表中某个选择器无效不影响其他选择器。这与传统选择器列表不同（一个无效导致整条规则失效）。' },
      { type: 'heading', text: ':where() — 零特异性匹配' },
      { type: 'paragraph', text: '`:where()` 与 `:is()` 功能完全相同，唯一区别是**特异性始终为 0**。这让 `:where()` 非常适合编写可覆盖的基础样式（如 CSS 框架、重置样式）。' },
      { type: 'code', code: '/* :where() 的特异性 = 0 */\n:where(#main, .card) { }  /* 特异性 = (0,0,0)，无论参数是什么 */\n\n/* 对比 :is() */\n:is(#main, .card) { }     /* 特异性 = (1,0,0) */', lang: 'css', caption: ':where() 特异性始终为 0' },
      { type: 'example', title: '框架样式与用户样式', code: '/* 框架的基础样式（使用 :where() 确保可覆盖）*/\n:where(h1, h2, h3) {\n  margin: 0;\n  color: #333;\n}\n\n/* 用户样式（普通类选择器即可覆盖）*/\n.my-title {\n  color: blue;  /* 轻松覆盖框架样式 */\n}', lang: 'css', explanation: ':where() 的零特异性确保用户样式可以轻松覆盖。' },
      { type: 'tip', text: 'Tailwind CSS 等工具类库大量使用 `:where()` 确保用户可以用简单的类名覆盖框架样式。' },
      { type: 'heading', text: ':has() — 关系选择器（父选择器）' },
      { type: 'paragraph', text: '`:has()` 是 CSS4 新增的**关系选择器**，根据**后代或兄弟元素的存在**来匹配元素。它常被称为"父选择器"，但实际上更强大——可以匹配任何与其他元素有关系的元素。' },
      { type: 'code', code: '/* :has() 根据后代匹配 */\na:has(> img) { }              /* 包含直接子元素 img 的 a */\narticle:has(h2) { }           /* 包含 h2 的 article */\nform:has(:invalid) { }        /* 包含无效输入的 form */\n\n/* :has() 根据兄弟匹配 */\nh1:has(+ p) { }               /* 后面紧跟 p 的 h1 */\nli:has(~ .active) { }         /* 后面有 .active 兄弟的 li */', lang: 'css', caption: ':has() 关系选择器' },
      { type: 'example', title: '实用场景：卡片根据内容调整样式', code: '/* 包含图片的卡片使用网格布局 */\n.card:has(img) {\n  display: grid;\n  grid-template-columns: 200px 1fr;\n}\n\n/* 不含图片的卡片使用普通块布局 */\n.card:not(:has(img)) {\n  display: block;\n}', lang: 'css', explanation: '根据卡片是否包含图片，自动切换布局方式。' },
      { type: 'example', title: '表单验证状态', code: '/* 包含无效输入的表单，显示错误提示 */\nform:has(:invalid) .error-message {\n  display: block;\n}\n\nform:not(:has(:invalid)) .error-message {\n  display: none;\n}', lang: 'css', explanation: '纯 CSS 实现表单验证反馈。' },
      { type: 'heading', text: ':has() 的特异性' },
      { type: 'paragraph', text: '`:has()` 的特异性**等于参数中最高的特异性**（与 `:is()` 相同）。' },
      { type: 'code', code: '/* :has() 的特异性 = 参数中最高值 */\na:has(> img) { }          /* 特异性 = (0,0,2)：a + img */\narticle:has(.highlight) { }  /* 特异性 = (0,1,1)：article + .highlight */', lang: 'css', caption: ':has() 特异性计算' },
      { type: 'warning', text: '`:has()` 的性能影响较大——浏览器需要检查每个元素的后代/兄弟。避免在通配符或过宽的选择器上使用（如 `*:has(p)` 会检查所有元素）。' },
      { type: 'list', items: [
        '`:not()` 排除匹配参数的元素，CSS4 支持选择器列表',
        '`:is()` 匹配参数列表中任一选择器，特异性为参数中最高值',
        '`:is()` 具有宽容性，一个选择器无效不影响其他',
        '`:where()` 功能同 `:is()`，但特异性始终为 0',
        '`:where()` 适合编写可覆盖的基础样式',
        '`:has()` 根据后代/兄弟元素的存在匹配元素',
        '`:has()` 常被称为"父选择器"，但能力更广',
        '`:has()` 特异性为参数中最高值，注意性能影响'
      ] },
      { type: 'tip', text: '逻辑伪类可以嵌套使用——`:is(.a, .b):not(.c)` 匹配含 `.a` 或 `.b` 但不含 `.c` 的元素。合理组合能实现非常复杂的匹配逻辑。' },
    ] as TutorialBlock[],
  },
  {
    id: 'pseudo-elements',
    number: '6',
    title: { zh: '伪元素', en: 'Pseudo-elements' },
    specId: 'pseudo-element-selectors',
    summary: { zh: '伪元素（pseudo-element）用双冒号 :: 表示（CSS3 语法），用于选择元素的特定部分或生成不存在于文档树中的内容。CSS2 定义了 ::first-line、::first-letter、::before、::after 四个伪元素。CSS3 统一采用双冒号语法以区分伪类，但为了向后兼容，浏览器仍然接受单冒号写法。现代 CSS 还引入了 ::marker、::placeholder、::selection 等新伪元素。', en: 'Pseudo-elements use double colons (::) in CSS3 syntax to select specific parts of elements or generate content that does not exist in the document tree. CSS2 defined four pseudo-elements: ::first-line, ::first-letter, ::before, and ::after. CSS3 standardized the double-colon syntax to distinguish from pseudo-classes, but browsers still accept single-colon syntax for backward compatibility. Modern CSS introduced new pseudo-elements like ::marker, ::placeholder, and ::selection.' },
    keyPoints: [
      '::before 和 ::after — 生成内容伪元素，配合 content 属性在元素前后插入内容',
      '::first-line — 匹配块级元素的首行文本，可设置字体、颜色、背景等',
      '::first-letter — 匹配块级元素的首字母，常用于首字下沉效果',
      '单冒号 vs 双冒号：CSS2 用单冒号（:before），CSS3 规范统一为双冒号（::before）',
      '浏览器为了兼容性同时接受两种写法，但推荐使用双冒号',
      '::marker（CSS3）— 匹配列表项的标记（如 li 的圆点或数字）',
      '::placeholder（CSS3）— 匹配表单输入框的占位符文本',
      '::selection（CSS3）— 匹配用户选中的文本，可自定义选中背景色',
      '每个选择器只能有一个伪元素，且必须出现在选择器末尾',
    ],
    tutorial: [
      { type: 'heading', text: '伪元素：选择元素的部分或生成内容' },
      { type: 'paragraph', text: '**伪元素**（pseudo-element）用双冒号 `::` 表示（CSS3 语法），用于选择元素的**特定部分**（如首行、首字母）或**生成不存在于文档树中的内容**（如 `::before`、`::after`）。伪元素让你可以样式化或添加内容，而不需要修改 HTML。' },
      { type: 'heading', text: '单冒号 vs 双冒号' },
      { type: 'paragraph', text: 'CSS2 使用单冒号语法（`:before`、`:after`），CSS3 统一改为双冒号（`::before`、`::after`）以区分伪类（单冒号）和伪元素（双冒号）。浏览器为了兼容性同时接受两种写法，但**推荐使用双冒号**。' },
      { type: 'code', code: '/* CSS2 语法（仍然有效）*/\np:before { content: "→ "; }\np:first-line { font-weight: bold; }\n\n/* CSS3 语法（推荐）*/\np::before { content: "→ "; }\np::first-line { font-weight: bold; }', lang: 'css', caption: '单冒号与双冒号等价，推荐双冒号' },
      { type: 'heading', text: '::before 和 ::after — 生成内容' },
      { type: 'paragraph', text: '`::before` 和 `::after` 是最常用的伪元素，用于在元素**内容前后**插入生成内容。必须配合 `content` 属性使用——`content` 定义要插入的内容（文本、图标、计数器等）。' },
      { type: 'code', code: '/* ::before 在内容前插入 */\nblockquote::before {\n  content: """;\n  font-size: 3em;\n  color: #ccc;\n}\n\n/* ::after 在内容后插入 */\na[href^="http"]::after {\n  content: " ↗";\n  font-size: 0.8em;\n}\n\n<!-- HTML -->\n<blockquote>引用内容</blockquote>  <!-- 渲染为：" 引用内容 -->\n<a href="https://example.com">链接</a>  <!-- 渲染为：链接 ↗ -->', lang: 'html', caption: '生成内容伪元素' },
      { type: 'example', title: '实用场景：清除浮动', code: '/* 经典 clearfix 技巧 */\n.clearfix::after {\n  content: "";\n  display: table;\n  clear: both;\n}', lang: 'css', explanation: '在容器末尾生成一个清除浮动的伪元素，无需额外 HTML。' },
      { type: 'tip', text: '`content: ""` 表示生成一个空内容的伪元素——它仍然会生成盒子，可以设置宽高、背景等，常用于装饰效果。' },
      { type: 'heading', text: '::first-line — 首行样式' },
      { type: 'paragraph', text: '`::first-line` 匹配块级元素的**首行文本**（无论文本多长，浏览器自动计算首行）。只能应用有限的属性：字体、颜色、背景、文本装饰等，不能改变布局（如 `margin`、`padding`）。' },
      { type: 'code', code: '/* 首行样式 */\np::first-line {\n  font-weight: bold;\n  color: navy;\n  text-transform: uppercase;\n}\n\n<!-- HTML -->\n<p>\n  这是第一行文本，会被加粗、蓝色、大写。\n  第二行不受影响。\n</p>', lang: 'html', caption: '首行伪元素' },
      { type: 'warning', text: '`::first-line` 的作用范围会随窗口宽度变化——调整窗口宽度会导致首行重新计算。它是动态的，不是固定的第一个 `<br>` 前的文本。' },
      { type: 'heading', text: '::first-letter — 首字母样式' },
      { type: 'paragraph', text: '`::first-letter` 匹配块级元素的**首字母**（包括前导标点符号，如引号）。常用于实现**首字下沉**（drop cap）效果。' },
      { type: 'example', title: '首字下沉效果', code: 'p::first-letter {\n  font-size: 3em;\n  font-weight: bold;\n  float: left;\n  line-height: 0.8;\n  margin-right: 0.1em;\n}\n\n<!-- HTML -->\n<p>曾经有一个首字下沉的段落...</p>', lang: 'html', explanation: '首字母放大并浮动，形成杂志式的首字下沉效果。' },
      { type: 'heading', text: '::marker — 列表标记' },
      { type: 'paragraph', text: '`::marker` 匹配列表项的**标记**（如 `<li>` 的圆点、数字）。CSS3 新增，允许你样式化列表标记而不需要 `list-style` 属性。' },
      { type: 'code', code: '/* 样式化列表标记 */\nli::marker {\n  color: red;\n  font-weight: bold;\n  content: "✓ ";\n}\n\n<!-- HTML -->\n<ul>\n  <li>列表项 1</li>  <!-- 标记：✓（红色加粗）-->\n  <li>列表项 2</li>\n</ul>', lang: 'html', caption: '::marker 伪元素' },
      { type: 'heading', text: '::placeholder — 占位符文本' },
      { type: 'paragraph', text: '`::placeholder` 匹配表单输入框的**占位符文本**（`placeholder` 属性）。可以自定义占位符的颜色、字体等。' },
      { type: 'code', code: '/* 样式化占位符 */\ninput::placeholder {\n  color: #999;\n  font-style: italic;\n  opacity: 1;  /* Firefox 默认 opacity < 1 */\n}\n\n<!-- HTML -->\n<input type="text" placeholder="请输入邮箱">', lang: 'html', caption: '占位符伪元素' },
      { type: 'tip', text: '不同浏览器的占位符默认样式不同——有的浅灰、有的半透明。统一样式化 `::placeholder` 能确保一致的视觉效果。' },
      { type: 'heading', text: '::selection — 选中文本' },
      { type: 'paragraph', text: '`::selection` 匹配用户**选中的文本**（拖动鼠标或双击）。可以自定义选中文本的背景色和文字颜色。' },
      { type: 'code', code: '/* 自定义选中样式 */\n::selection {\n  background: #ffeb3b;\n  color: #000;\n}\n\n/* 针对特定元素 */\ncode::selection {\n  background: #333;\n  color: #fff;\n}', lang: 'css', caption: '选中文本样式' },
      { type: 'warning', text: '`::selection` 只能设置 `color`、`background-color`、`text-shadow` 等有限属性，不能改变布局。' },
      { type: 'heading', text: '伪元素的限制' },
      { type: 'list', items: [
        '每个选择器只能有**一个**伪元素：`p::before::after` 是无效的',
        '伪元素必须出现在选择器**末尾**：`::before p` 是无效的，应该是 `p::before`',
        '伪元素生成的内容只存在于**格式化结构**中，不在文档树中——JavaScript 的 DOM API 看不到伪元素',
        '并非所有 CSS 属性都能应用于伪元素——例如 `::first-line` 不能设置 `margin`、`padding`'
      ] },
      { type: 'code', code: '/* ✓ 正确 */\np::before { content: "→"; }\ndiv.card::after { content: ""; }\n\n/* ✗ 错误 */\n::before p { }              /* 伪元素不能在开头 */\np::before::after { }        /* 不能有多个伪元素 */\np::before { }               /* ::before 必须有 content 属性 */', lang: 'css', caption: '伪元素使用规则' },
      { type: 'list', items: [
        '伪元素用双冒号 `::`（CSS3 语法），伪类用单冒号 `:`',
        '`::before` 和 `::after` 生成内容，必须配合 `content` 属性',
        '`::first-line` 匹配首行文本，`::first-letter` 匹配首字母',
        '`::marker` 样式化列表标记，`::placeholder` 样式化占位符',
        '`::selection` 自定义选中文本样式',
        '每个选择器只能有一个伪元素，且必须在末尾',
        '伪元素生成的内容不在文档树中，JavaScript 无法访问'
      ] },
      { type: 'tip', text: '伪元素是 CSS 中最强大的装饰工具——合理使用能大幅减少 HTML 标签数量，让结构更简洁、样式更灵活。' },
    ] as TutorialBlock[],
  },
  {
    id: 'specificity-calculation',
    number: '7',
    title: { zh: '特异性计算', en: 'Specificity Calculation' },
    specId: 'specificity',
    summary: { zh: '特异性（specificity）是 CSS 层叠机制的核心组成部分，用于决定当多条规则作用于同一属性时哪条规则胜出。特异性用 (a, b, c) 三元组表示：a 是 ID 选择器数量，b 是类/属性/伪类选择器数量，c 是类型/伪元素选择器数量。比较时从左到右依次比较，a 最高。逻辑伪类（:is()、:not()、:has()）不计入特异性，但它们的参数会；:where() 特异性为 0。', en: 'Specificity is a core component of the CSS cascade mechanism, determining which rule wins when multiple rules affect the same property. Specificity is represented as a triplet (a, b, c): a is the count of ID selectors, b is the count of class/attribute/pseudo-class selectors, c is the count of type/pseudo-element selectors. Comparison is done left to right, with a being highest. Logical pseudo-classes (:is(), :not(), :has()) do not contribute to specificity, but their arguments do; :where() has zero specificity.' },
    keyPoints: [
      '特异性三元组 (a, b, c)：a = ID 数量，b = class/attr/伪类数量，c = type/伪元素数量',
      'ID 选择器（#id）贡献 (1,0,0)，类选择器（.class）贡献 (0,1,0)，类型选择器（div）贡献 (0,0,1)',
      '属性选择器 [attr] 和伪类 :hover 都贡献 (0,1,0)',
      '伪元素 ::before 贡献 (0,0,1)',
      '通配符 *、组合符（>、+、~、空格）不贡献特异性',
      ':is()、:not()、:has() 本身不贡献特异性，但取参数列表中最高的特异性',
      ':where() 的特异性始终为 0，无论参数是什么',
      '行内样式 style="..." 的特异性为 (1,0,0,0)（四元组），高于任何选择器',
      '!important 不是特异性机制，而是层叠层面的优先级提升',
      '示例：div#main .card > p.intro:hover 的特异性是 (1, 2, 2)',
    ],
    tutorial: [
      { type: 'heading', text: '特异性：层叠的决定性因素' },
      { type: 'paragraph', text: '**特异性**（specificity）是 CSS 层叠机制的核心组成部分。当多条规则作用于同一元素的同一属性时，浏览器通过**特异性**决定哪条规则胜出。特异性越高，优先级越高。理解特异性计算是掌握 CSS 优先级的关键。' },
      { type: 'heading', text: '特异性三元组 (a, b, c)' },
      { type: 'paragraph', text: '特异性用三元组 `(a, b, c)` 表示，每个位置统计不同类型的选择器数量：' },
      { type: 'list', items: [
        '**a**：ID 选择器的数量（`#id`）',
        '**b**：类选择器（`.class`）、属性选择器（`[attr]`）、伪类（`:hover`）的数量',
        '**c**：类型选择器（`div`、`p`）、伪元素（`::before`）的数量'
      ] },
      { type: 'code', code: '/* 特异性计算示例 */\n#main { }                  /* (1,0,0) — 1 个 ID */\n.card { }                  /* (0,1,0) — 1 个类 */\ndiv { }                    /* (0,0,1) — 1 个类型 */\n\ndiv.card { }               /* (0,1,1) — 1 类 + 1 类型 */\n#main .card { }            /* (1,1,0) — 1 ID + 1 类 */\na:hover { }                /* (0,1,1) — 1 伪类 + 1 类型 */\n\ndiv#main .card > p.intro:hover {\n  /* (1,2,2) — 1 ID + 2 类/伪类 + 2 类型 */\n}', lang: 'css', caption: '特异性计算' },
      { type: 'heading', text: '比较规则：从左到右' },
      { type: 'paragraph', text: '特异性比较时**从左到右**依次比较，a 位最高。`(1,0,0)` 大于 `(0,99,99)`——一个 ID 选择器胜过任意数量的类选择器。' },
      { type: 'example', title: '特异性比较', code: '/* (1,0,0) vs (0,1,0) */\n#header { color: red; }      /* (1,0,0) 胜出 */\n.header { color: blue; }     /* (0,1,0) */\n\n<!-- HTML -->\n<div id="header" class="header">红色</div>  <!-- ID 选择器胜出 */\n\n/* (0,2,0) vs (0,1,1) */\n.nav.primary { }             /* (0,2,0) 胜出 */\nul.nav { }                   /* (0,1,1) */', lang: 'html', explanation: '比较时从 a 开始，a 相同才比较 b，b 相同才比较 c。' },
      { type: 'heading', text: '不计入特异性的选择器' },
      { type: 'paragraph', text: '**通配符** `*`、**组合符**（空格、`>`、`+`、`~`）**不贡献特异性**——它们的特异性为 `(0,0,0)`。' },
      { type: 'code', code: '/* 通配符和组合符不计入 */\n* { }                      /* (0,0,0) */\ndiv > p { }                /* (0,0,2) — 只计 div 和 p */\nh1 + p { }                 /* (0,0,2) — 只计 h1 和 p */\n.container * { }           /* (0,1,0) — 只计 .container */', lang: 'css', caption: '通配符和组合符特异性为 0' },
      { type: 'heading', text: '逻辑伪类的特异性' },
      { type: 'paragraph', text: '`:is()`、`:not()`、`:has()` **本身不贡献特异性**，但取**参数列表中最高的特异性**。`:where()` 的特异性**始终为 0**，无论参数是什么。' },
      { type: 'code', code: '/* :is() 取参数中最高特异性 */\n:is(#main, .card) { }      /* (1,0,0) — 等于 #main */\n:is(div, .card) { }        /* (0,1,0) — 等于 .card */\n:is(div, p) { }            /* (0,0,1) — 等于 div 或 p */\n\n/* :not() 同理 */\np:not(#intro) { }          /* (1,0,1) — 1 ID + 1 类型 */\np:not(.intro) { }          /* (0,1,1) — 1 类 + 1 类型 */\n\n/* :where() 始终为 0 */\n:where(#main, .card) { }   /* (0,0,0) — 无论参数是什么 */', lang: 'css', caption: '逻辑伪类的特异性' },
      { type: 'tip', text: '`:where()` 的零特异性让它非常适合编写可覆盖的基础样式——用户可以用普通类选择器轻松覆盖 `:where()` 规则。' },
      { type: 'heading', text: '行内样式：四元组 (1,0,0,0)' },
      { type: 'paragraph', text: '**行内样式**（`style="..."`）的特异性是 `(1,0,0,0)`（四元组），**高于任何选择器**。只有 `!important` 可以覆盖行内样式。' },
      { type: 'code', code: '/* 选择器 */\n#main { color: red; }      /* (1,0,0) */\n\n<!-- HTML -->\n<div id="main" style="color: blue;">蓝色</div>  <!-- 行内样式 (1,0,0,0) 胜出 */', lang: 'html', caption: '行内样式优先级最高' },
      { type: 'warning', text: '行内样式的高特异性会让样式难以覆盖——现代最佳实践是**避免使用行内样式**，用类名代替。行内样式与 CSS 的"内容与表现分离"原则相悖。' },
      { type: 'heading', text: '!important：层叠层面的提升' },
      { type: 'paragraph', text: '`!important` **不是特异性机制**——它是**层叠层面**的优先级提升。`!important` 声明会进入单独的层叠层，优先级高于所有普通声明。第 4 章会详细讲解层叠算法。' },
      { type: 'code', code: '/* !important 提升到层叠高层 */\np { color: red !important; }  /* 即使特异性低，也会胜出 */\n#main p { color: blue; }      /* (1,0,1) 但输给 !important */', lang: 'css', caption: '!important 超越特异性' },
      { type: 'warning', text: '**不要滥用 !important**——它会破坏层叠的自然顺序，让样式难以维护和调试。只在绝对必要时使用（如覆盖第三方库的样式）。' },
      { type: 'heading', text: '实战示例：计算复杂选择器' },
      { type: 'example', title: '完整计算过程', code: '/* 选择器 */\ndiv#main .card > p.intro:hover::before\n\n/* 拆解：\n   div        — 类型   → c+1\n   #main      — ID     → a+1\n   .card      — 类     → b+1\n   >          — 组合符 → 不计\n   p          — 类型   → c+1\n   .intro     — 类     → b+1\n   :hover     — 伪类   → b+1\n   ::before   — 伪元素 → c+1\n*/\n\n/* 特异性 = (1, 3, 3) */\n/*   a=1 (1个ID), b=3 (3个类/伪类), c=3 (3个类型/伪元素) */', lang: 'css', explanation: '逐个统计每种选择器，组合符不计入。' },
      { type: 'list', items: [
        '特异性三元组：a = ID，b = 类/属性/伪类，c = 类型/伪元素',
        '比较时从左到右，a 最高，一个 ID 胜过任意数量的类',
        '通配符 `*` 和组合符（空格、`>`、`+`、`~`）不计入特异性',
        '`:is()`、`:not()`、`:has()` 取参数中最高特异性',
        '`:where()` 特异性始终为 0，适合可覆盖的基础样式',
        '行内样式特异性为 (1,0,0,0)，高于任何选择器',
        '`!important` 不是特异性机制，而是层叠层面的提升'
      ] },
      { type: 'tip', text: '特异性是工具，不是目标——不要为了提高特异性而堆叠选择器。简洁、可维护的选择器比高特异性更重要。当你发现需要 `!important` 时，先检查是否是特异性设计出了问题。' },
    ] as TutorialBlock[],
  },
  {
    id: 'selector-performance',
    number: '8',
    title: { zh: '选择器性能与最佳实践', en: 'Selector Performance & Best Practices' },
    summary: { zh: '选择器的性能影响主要来自浏览器的匹配机制。浏览器从右向左匹配选择器，先找到右侧的"关键选择器"（key selector）对应的所有元素，再逐个检查左侧条件。因此，右侧选择器过于宽泛（如 * 或 div）会导致大量不必要的匹配尝试。不过现代浏览器的选择器引擎已经高度优化，选择器性能很少成为实际瓶颈——可读性和可维护性通常更重要。', en: 'Selector performance impact mainly comes from browser matching mechanisms. Browsers match selectors right to left, first finding all elements matching the "key selector" on the right, then checking left-side conditions for each. Thus, overly broad right-side selectors (like * or div) cause many unnecessary matching attempts. However, modern browser selector engines are highly optimized, and selector performance rarely becomes an actual bottleneck—readability and maintainability are usually more important.' },
    keyPoints: [
      '浏览器从右向左匹配：div p.intro 先找所有 .intro 的 p，再向上查找 div 祖先',
      '关键选择器（key selector）是最右侧的选择器，决定了初始匹配范围',
      '避免关键选择器过于宽泛：body * { } 会对每个元素进行匹配检查',
      '避免过深的后代选择器：html body div div div p 性能较差且难以维护',
      'BEM 等命名方法论通过单一类名降低选择器复杂度：.card__title 而非 .card .title',
      '现代浏览器的选择器引擎使用 Bloom filter 等技术加速匹配，性能已不是主要问题',
      '实际优化建议：优先考虑可读性和可维护性，只在性能分析确认瓶颈时才优化选择器',
      '真正的性能瓶颈通常在布局计算和绘制，而非选择器匹配',
    ],
    tutorial: [
      { type: 'heading', text: '选择器性能：理解匹配机制' },
      { type: 'paragraph', text: '选择器的性能影响主要来自浏览器的**匹配机制**。理解浏览器如何匹配选择器，能帮助你写出高效的选择器。但更重要的是：**现代浏览器的选择器引擎已经高度优化**，选择器性能很少成为实际瓶颈——可读性和可维护性通常更重要。' },
      { type: 'heading', text: '关键选择器：匹配的起点' },
      { type: 'paragraph', text: '浏览器从右向左匹配选择器，**最右侧的选择器**被称为**关键选择器**（key selector）。浏览器先找到所有匹配关键选择器的元素，然后逐个检查左侧条件。关键选择器决定了**初始匹配范围**——范围越大，性能开销越大。' },
      { type: 'code', code: '/* 匹配过程示例 */\ndiv p.intro { }\n\n/* 浏览器执行步骤：\n   1. 找到所有 class="intro" 的 <p>（关键选择器）\n   2. 对每个 p.intro，检查祖先中是否有 <div>\n   3. 匹配的元素应用样式\n*/', lang: 'css', caption: '从右向左匹配' },
      { type: 'heading', text: '性能陷阱：过宽的关键选择器' },
      { type: 'paragraph', text: '关键选择器过于宽泛会导致大量不必要的匹配尝试。通配符 `*` 或常见标签（`div`、`span`）作为关键选择器时，浏览器需要检查**所有**或**大量**元素。' },
      { type: 'example', title: '性能差的选择器', code: '/* ✗ 差：关键选择器是通配符 */\n.container * { }         /* 检查 .container 内的每个元素 */\n\n/* ✗ 差：关键选择器是常见标签 */\n.sidebar div { }         /* 检查所有 div，再筛选 .sidebar 内的 */\n\n/* ✓ 好：关键选择器较窄 */\n.sidebar .widget { }     /* 只检查 .widget，范围更小 */', lang: 'css', explanation: '关键选择器越窄，初始匹配范围越小。' },
      { type: 'heading', text: '避免过深的后代选择器' },
      { type: 'paragraph', text: '过深的后代选择器（如 `html body div div div p`）不仅性能较差，还难以维护、特异性过高。通常 2-3 层已经足够——更多层往往是过度依赖 DOM 结构的信号。' },
      { type: 'code', code: '/* ✗ 差：过深的后代选择器 */\nhtml body main article section div p { }\n\n/* ✓ 好：2-3 层足够 */\narticle p { }\n.content p { }\n\n/* ✓ 更好：单一类名 */\n.article-paragraph { }', lang: 'css', caption: '避免过深嵌套' },
      { type: 'tip', text: '如果你发现选择器超过 3 层，考虑添加一个语义化的类名——这比堆叠选择器更好。' },
      { type: 'heading', text: 'BEM：降低选择器复杂度' },
      { type: 'paragraph', text: '**BEM**（Block Element Modifier）等命名方法论通过**单一类名**降低选择器复杂度。`.card__title` 比 `.card .title` 更高效（关键选择器更具体）、特异性更低（易于覆盖）、不依赖 DOM 结构（更灵活）。' },
      { type: 'example', title: 'BEM vs 后代选择器', code: '/* 传统后代选择器 */\n.card .title { }              /* 依赖 DOM 结构 */\n.card .meta .author { }       /* 特异性 (0,3,0) */\n\n/* BEM 命名 */\n.card__title { }              /* 单一类名，特异性 (0,1,0) */\n.card__author { }             /* 不依赖结构 */', lang: 'css', explanation: 'BEM 用命名约定替代选择器嵌套。' },
      { type: 'heading', text: '现代浏览器的优化' },
      { type: 'paragraph', text: '现代浏览器的选择器引擎使用多种技术加速匹配：**Bloom filter**（快速排除不匹配的元素）、**样式共享**（相同选择器的元素共享计算结果）、**增量更新**（只重新计算变化的部分）。这些优化让选择器性能影响大幅降低。' },
      { type: 'code', code: '/* 即使这样写，现代浏览器也能高效处理 */\n.container > .row > .col > .card { }\n\n/* 但更推荐这样（可读性和可维护性更好）*/\n.card { }', lang: 'css', caption: '性能已不是主要问题' },
      { type: 'heading', text: '真正的性能瓶颈' },
      { type: 'paragraph', text: '实际开发中，真正的性能瓶颈通常**不是选择器匹配**，而是：' },
      { type: 'list', items: [
        '**布局计算**（layout/reflow）：修改几何属性（`width`、`height`、`margin`）触发重新布局',
        '**绘制**（paint）：修改视觉属性（`color`、`background`）触发重新绘制',
        '**JavaScript 操作 DOM**：频繁增删元素、修改样式',
        '**大型 DOM 树**：数千个元素的页面，任何操作都慢',
        '**复杂动画**：同时运行多个动画、动画属性触发布局'
      ] },
      { type: 'tip', text: '优化性能时，先用浏览器 DevTools 的 Performance 面板找到真正的瓶颈——不要凭猜测优化。' },
      { type: 'heading', text: '选择器最佳实践' },
      { type: 'list', ordered: true, items: [
        '**优先考虑可读性和可维护性**——除非性能分析确认瓶颈，否则不要为性能牺牲可读性',
        '**避免过宽的关键选择器**——不要用通配符或常见标签作为关键选择器',
        '**避免过深的后代选择器**——通常 2-3 层已足够，更多层考虑添加类名',
        '**优先使用类选择器**——比 ID 更灵活，比标签更精确',
        '**考虑命名方法论**（如 BEM）——用命名约定替代选择器嵌套',
        '**不要过早优化**——先写清晰的选择器，确认瓶颈后再优化'
      ] },
      { type: 'code', code: '/* ✓ 好的选择器：清晰、简洁、可维护 */\n.button { }\n.button--primary { }\n.card__header { }\nnav .nav-link { }\n\n/* ✗ 避免：复杂、脆弱、难维护 */\nhtml body div#main div.container > div.row div.col-6 p.text { }\n#wrapper * { }\ndiv div div div { }', lang: 'css', caption: '好的选择器 vs 差的选择器' },
      { type: 'warning', text: '不要为了性能而牺牲语义——`.text-blue` 不如 `.highlight` 语义化，即使性能相同。可维护性比微小的性能差异更重要。' },
      { type: 'list', items: [
        '浏览器从右向左匹配，关键选择器决定初始匹配范围',
        '避免过宽的关键选择器（通配符、常见标签）',
        '避免过深的后代选择器（超过 3 层考虑添加类名）',
        'BEM 等命名方法论用命名约定替代选择器嵌套',
        '现代浏览器选择器引擎已高度优化，性能影响较小',
        '真正的性能瓶颈在布局计算和绘制，而非选择器匹配',
        '优先考虑可读性和可维护性，只在确认瓶颈时优化'
      ] },
      { type: 'tip', text: '选择器性能的黄金法则：**先写清晰的代码，再优化瓶颈**。过早优化是万恶之源——不要为了假设的性能问题而牺牲代码质量。' },
    ] as TutorialBlock[],
  },
];

export const anchors: Record<string, string> = {
  // §1 selector-overview
  'pattern-matching': 'selector-overview',
  'selector-syntax': 'selector-overview',
  'grouping': 'selector-overview',

  // §2 simple-selectors
  'universal-selector': 'simple-selectors',
  'type-selectors': 'simple-selectors',
  'attribute-selectors': 'simple-selectors',
  'matching-attrs': 'simple-selectors',
  'default-attrs': 'simple-selectors',
  'class-html': 'simple-selectors',
  'id-selectors': 'simple-selectors',

  // §3 combinators
  'descendant-selectors': 'combinators',
  'child-selectors': 'combinators',
  'adjacent-selectors': 'combinators',

  // §4 pseudo-classes
  'pseudo-elements': 'pseudo-classes',
  'first-child': 'pseudo-classes',
  'link-pseudo-classes': 'pseudo-classes',
  'dynamic-pseudo-classes': 'pseudo-classes',
  'lang': 'pseudo-classes',

  // §6 pseudo-elements
  'pseudo-element-selectors': 'pseudo-elements',
  'first-line-pseudo': 'pseudo-elements',
  'first-letter': 'pseudo-elements',
  'before-and-after': 'pseudo-elements',

  // §7 specificity-calculation
  'specificity': 'specificity-calculation',
};

export const glossaryTerms: Record<string, GlossaryEntry> = {
  'selector': {
    zh: '选择器',
    description: '用于匹配文档中元素的模式，决定样式规则应用到哪些元素上。',
    sectionRef: 'selectors#selector-overview',
    css2Url: 'https://www.w3.org/TR/CSS22/selector.html',
    specUrl: 'https://www.w3.org/TR/selectors-4/',
  },
  'simple selector': {
    zh: '简单选择器',
    description: '单一的选择条件，如类型选择器（div）、类选择器（.class）、ID 选择器（#id）、属性选择器、伪类等。',
    sectionRef: 'selectors#simple-selectors',
    specUrl: 'https://www.w3.org/TR/selectors-4/#simple',
  },
  'compound selector': {
    zh: '复合选择器',
    description: '多个简单选择器紧密连接（无空格），如 div.card#main。所有条件必须同时满足。',
    sectionRef: 'selectors#selector-overview',
    specUrl: 'https://www.w3.org/TR/selectors-4/#compound',
  },
  'complex selector': {
    zh: '复杂选择器',
    description: '用组合器（空格、>、+、~）连接多个复合选择器，描述元素之间的关系。',
    sectionRef: 'selectors#selector-overview',
    specUrl: 'https://www.w3.org/TR/selectors-4/#complex',
  },
  'combinator': {
    zh: '组合器',
    description: '连接选择器的符号，表示元素间关系：空格（后代）、>（子代）、+（相邻兄弟）、~（通用兄弟）。',
    sectionRef: 'selectors#combinators',
    css2Url: 'https://www.w3.org/TR/CSS22/selector.html#descendant-selectors',
    specUrl: 'https://www.w3.org/TR/selectors-4/#combinators',
  },
  'pseudo-class': {
    zh: '伪类',
    description: '用单冒号表示的选择器，描述元素的特定状态或位置，如 :hover、:first-child、:checked。',
    sectionRef: 'selectors#pseudo-classes',
    css2Url: 'https://www.w3.org/TR/CSS22/selector.html#pseudo-elements',
    specUrl: 'https://www.w3.org/TR/selectors-4/#pseudo-classes',
  },
  'pseudo-element': {
    zh: '伪元素',
    description: '用双冒号表示，选择元素的特定部分或生成内容，如 ::before、::after、::first-line。',
    sectionRef: 'selectors#pseudo-elements',
    css2Url: 'https://www.w3.org/TR/CSS22/selector.html#pseudo-element-selectors',
    specUrl: 'https://www.w3.org/TR/selectors-4/#pseudo-elements',
  },
  'type selector': {
    zh: '类型选择器',
    description: '匹配特定元素名的选择器，如 h1、div、p。',
    sectionRef: 'selectors#simple-selectors',
    css2Url: 'https://www.w3.org/TR/CSS22/selector.html#type-selectors',
    specUrl: 'https://www.w3.org/TR/selectors-4/#type-selectors',
  },
  'class selector': {
    zh: '类选择器',
    description: '以点号开头的选择器，匹配 class 属性值，如 .card 匹配 class="card"。',
    sectionRef: 'selectors#simple-selectors',
    css2Url: 'https://www.w3.org/TR/CSS22/selector.html#class-html',
    specUrl: 'https://www.w3.org/TR/selectors-4/#class-html',
  },
  'id selector': {
    zh: 'ID 选择器',
    description: '以井号开头的选择器，匹配 id 属性值，如 #main 匹配 id="main"。',
    sectionRef: 'selectors#simple-selectors',
    css2Url: 'https://www.w3.org/TR/CSS22/selector.html#id-selectors',
    specUrl: 'https://www.w3.org/TR/selectors-4/#id-selectors',
  },
  'attribute selector': {
    zh: '属性选择器',
    description: '匹配具有特定属性或属性值的元素，如 [type="text"]、[class~="active"]。',
    sectionRef: 'selectors#simple-selectors',
    css2Url: 'https://www.w3.org/TR/CSS22/selector.html#attribute-selectors',
    specUrl: 'https://www.w3.org/TR/selectors-4/#attribute-selectors',
  },
  ':has()': {
    zh: '关系伪类',
    description: 'CSS4 新增的关系选择器，根据后代或兄弟元素的存在来匹配元素，如 a:has(> img) 匹配包含图片的链接。',
    sectionRef: 'selectors#logical-pseudo-classes',
    specUrl: 'https://www.w3.org/TR/selectors-4/#relational',
  },
  ':is()': {
    zh: '匹配列表伪类',
    description: '匹配参数列表中任一选择器的元素，具有宽容性，特异性为参数中最高值。',
    sectionRef: 'selectors#logical-pseudo-classes',
    specUrl: 'https://www.w3.org/TR/selectors-4/#matches',
  },
  ':where()': {
    zh: '零特异性匹配伪类',
    description: '功能与 :is() 相同，但特异性始终为 0，常用于工具类库。',
    sectionRef: 'selectors#logical-pseudo-classes',
    specUrl: 'https://www.w3.org/TR/selectors-4/#zero-matches',
  },
  'specificity': {
    zh: '特异性',
    description: '选择器的优先级权重，用 (a, b, c) 三元组表示，a 为 ID 数量，b 为类/属性/伪类数量，c 为类型/伪元素数量。',
    sectionRef: 'selectors#specificity-calculation',
    css2Url: 'https://www.w3.org/TR/CSS22/cascade.html#specificity',
    specUrl: 'https://www.w3.org/TR/selectors-4/#specificity-rules',
  },
};

import type { Section, TutorialBlock } from '../modules';
import type { GlossaryEntry } from '../glossary';
import type { PropertyEntry } from '../properties';

export const sections: Section[] = [
  {
    id: 'intro',
    number: '1',
    title: { zh: '简介', en: 'Introduction' },
    summary: { zh: 'CSS 通过属性来控制文档的渲染。每个属性有名称、值域和行为定义。', en: 'CSS controls document rendering through properties. Each property has a name, value domain, and behavior definition.' },
    keyPoints: [
      'CSS 属性定义了元素的视觉表现',
      '层叠机制解决多个规则冲突的问题',
      '继承机制让某些属性值从父元素传递到子元素',
      '每个属性有名称、值域(value space)和对渲染行为的定义',
      '层叠和默认处理以一组声明为输入,为每个元素的每个属性输出一个指定值(specified value)',
      '本模块替换并扩展了 CSS2 第 6 章关于属性值赋值、层叠和继承的规则',
      '文本节点被视为其关联元素的子元素,拥有完整的属性集;但由于无法被选择器匹配,其计算值全部由默认处理(defaulting)决定',
      '未连接到文档树或不在扁平树(flat tree)中的元素不参与 CSS 值处理,没有任何阶段的值',
      '属性通过属性声明(property declaration)赋值,将值(如 red、12pt)分配给对应元素或盒子',
    ],
    tutorial: [
      { type: 'heading', text: 'CSS 属性：渲染的控制参数' },
      { type: 'paragraph', text: 'CSS 通过**属性**（property）来控制文档的视觉表现。每个属性都是一个渲染参数——`color` 控制文字颜色，`font-size` 控制字号，`margin` 控制外边距。属性有三个核心组成部分：**名称**（property name）、**值域**（value space，该属性接受的合法值集合）、**行为定义**（该属性如何影响渲染）。' },
      { type: 'code', code: '/* 属性示例 */\np {\n  color: navy;           /* 属性名: color, 值: navy */\n  font-size: 16px;       /* 属性名: font-size, 值: 16px */\n  margin: 1em 0;         /* 属性名: margin, 值: 1em 0 */\n}', lang: 'css', caption: '属性是 CSS 的基本控制单元' },
      { type: 'heading', text: '层叠与继承：解决值冲突的两大机制' },
      { type: 'paragraph', text: '当多条规则试图为同一个元素的同一个属性设置值时，CSS 通过**层叠**（cascade）机制决定哪条规则胜出。层叠按来源、重要性、特异性和顺序排序。对于没有声明值的属性，CSS 通过**继承**（inheritance）或**初始值**（initial value）确定属性值——这个过程叫**默认处理**（defaulting）。' },
      { type: 'example', title: '层叠解决冲突', code: '/* 两条规则都匹配 <p class="intro"> */\np { color: blue; }       /* 特异性: (0,0,1) */\n.intro { color: red; }  /* 特异性: (0,1,0) 胜出 */\n\n<p class="intro">这段文字是红色</p>', lang: 'css', explanation: '层叠机制按特异性排序，class 选择器优先级高于标签选择器，所以文字显示为红色。' },
      { type: 'heading', text: '值的处理流程：从声明到实际值' },
      { type: 'paragraph', text: 'CSS 规范定义了属性值的完整处理流程，分为 6 个阶段：**声明值**（declared value）→ **层叠值**（cascaded value）→ **指定值**（specified value）→ **计算值**（computed value）→ **使用值**（used value）→ **实际值**（actual value）。每个阶段都有明确的计算规则，最终得到浏览器用于渲染的实际值。' },
      { type: 'list', ordered: true, items: [
        '**声明值**：所有适用于该元素该属性的声明值集合（可能有多个）',
        '**层叠值**：层叠排序后胜出的那个声明值（最多一个）',
        '**指定值**：层叠值或默认处理后的值（每个属性恰好一个）',
        '**计算值**：将相对值（em、百分比）尽可能解析为绝对值',
        '**使用值**：将计算值完成所有剩余计算（如百分比宽度需要包含块尺寸）',
        '**实际值**：使用值经过环境限制调整后的最终渲染值'
      ] },
      { type: 'heading', text: '属性声明：赋值的基本单元' },
      { type: 'paragraph', text: '**属性声明**（property declaration）是将值分配给属性的基本语法单元。声明由属性名、冒号、值和分号组成。声明出现在样式规则的声明块中，或元素的 `style` 属性中（内联样式）。' },
      { type: 'code', code: '/* 样式规则中的声明 */\nh1 {\n  color: navy;      /* ← 属性声明 */\n  font-size: 2em;   /* ← 属性声明 */\n}\n\n<!-- 内联样式中的声明 -->\n<p style="color: red; margin: 1em;">内联声明</p>', lang: 'css' },
      { type: 'heading', text: '文本节点的属性值' },
      { type: 'paragraph', text: 'CSS 规范将**文本节点**（text node）视为其关联元素的子元素，并赋予完整的属性集。但由于文本节点无法被选择器匹配，它们的所有属性值都由**默认处理**决定——通常是从父元素继承（对于继承属性）或使用初始值（对于非继承属性）。' },
      { type: 'example', title: '文本节点继承父元素的 color', code: '<div style="color: green;">\n  这段文字是绿色的  <!-- 文本节点继承了 div 的 color -->\n</div>', lang: 'html', explanation: '文本节点没有自己的声明，通过继承获得 `color: green`。' },
      { type: 'warning', text: '未连接到文档树或不在扁平树（flat tree）中的元素**不参与 CSS 值处理**——它们没有任何阶段的值，也不会被渲染。例如 `<template>` 中的内容、未附加的 DOM 节点。' },
      { type: 'heading', text: '本模块的范围' },
      { type: 'paragraph', text: 'CSS Cascade 模块定义了属性值的赋值、层叠和继承规则。它替换并扩展了 CSS2.1 第 6 章的内容，新增了层叠层（`@layer`）、`revert-layer` 关键字、更清晰的值处理阶段定义。后续章节会详细讲解每个机制。' },
      { type: 'tip', text: '理解层叠和继承是掌握 CSS 的关键——它们决定了为什么你的样式会「生效」或「不生效」。' },
    ] as TutorialBlock[],
  },
  {
    id: 'at-import',
    number: '2',
    title: { zh: '导入样式表', en: '@import' },
    summary: { zh: '@import 规则允许从其他样式表导入规则。导入的样式表被视为在 @import 位置展开。', en: 'The @import rule allows importing rules from other stylesheets. Imported stylesheets are treated as expanded at the @import position.' },
    keyPoints: [
      '@import 必须在样式表最前面(除了 @charset),否则无效',
      '可以添加媒体查询条件,指定在特定媒体类型下才应用导入的样式',
      '支持 supports() 条件判断,UA 可在条件不匹配时跳过加载资源',
      '导入的样式表的层叠来源与导入它的样式表相同',
      '同一样式表在多处导入时,UA 必须将每次链接视为独立样式表进行处理(但可缓存资源)',
      '@import 支持 url() 和裸字符串两种语法,效果完全等价',
      '导入条件(import conditions)不匹配时,等效于将导入的样式表包裹在对应的 @media/@supports 块中',
      'CSS Cascade 5 新增 layer 关键字,可将导入的样式表分配到指定层叠层(cascade layer)',
      '导入的样式表的编码环境(environment encoding)继承自导入它的样式表',
      '资源的 Content-Type 必须为 text/css 才会被解析为样式表,否则视为网络错误',
    ],
    tutorial: [
      { type: 'heading', text: '@import：模块化样式表的基础' },
      { type: 'paragraph', text: '`@import` 规则允许从其他样式表导入规则，实现样式的模块化组织。导入的样式表被视为在 `@import` 位置**展开**——就像你把导入文件的内容直接粘贴到那里一样。这让你可以将样式拆分到多个文件，按功能或组件组织，同时保持层叠顺序的可预测性。' },
      { type: 'code', code: '/* main.css */\n@import "reset.css";        /* 重置样式 */\n@import "typography.css";  /* 字体排版 */\n@import "layout.css";      /* 布局 */\n@import "components.css";  /* 组件样式 */\n\n/* 自定义规则写在导入之后 */\nbody {\n  background: white;\n}', lang: 'css', caption: '使用 @import 组织样式结构' },
      { type: 'heading', text: '位置限制：必须在最前面' },
      { type: 'paragraph', text: '`@import` 规则**必须在样式表的最前面**（除了 `@charset` 和 `@layer` 声明语句）。任何出现在普通规则之后的 `@import` 都会被忽略。这个限制确保了层叠顺序的清晰性——导入的样式总是在当前样式表的自定义规则之前。' },
      { type: 'example', title: '错误的 @import 位置', code: '/* 错误示例 */\nbody { margin: 0; }\n@import "late.css";  /* ❌ 无效！在普通规则之后 */\n\n/* 正确示例 */\n@import "early.css"; /* ✓ 在所有普通规则之前 */\nbody { margin: 0; }', lang: 'css', explanation: '第一个 `@import` 因为出现在 `body` 规则之后而被忽略，不会加载 `late.css`。' },
      { type: 'heading', text: '语法形式：url() 和裸字符串' },
      { type: 'paragraph', text: '`@import` 支持两种语法形式：`url()` 函数和裸字符串，效果完全等价。推荐使用裸字符串形式，更简洁。' },
      { type: 'code', code: '/* 两种语法形式 */\n@import url("style.css");  /* url() 函数形式 */\n@import "style.css";       /* 裸字符串形式（推荐）*/\n\n/* 都等价于将 style.css 的内容展开到此处 */', lang: 'css' },
      { type: 'heading', text: '条件导入：媒体查询与特性检测' },
      { type: 'paragraph', text: '你可以为 `@import` 添加**导入条件**（import conditions），让样式表仅在特定条件下生效。支持媒体查询（`@media`）和特性检测（`supports()`）。条件不匹配时，等效于将导入的样式包裹在对应的条件块中。' },
      { type: 'code', code: '/* 媒体查询条件 */\n@import "mobile.css" (max-width: 768px);\n@import "print.css" print;\n\n/* 特性检测条件 */\n@import "modern.css" supports(display: grid);\n\n/* 组合条件 */\n@import "dark.css" (prefers-color-scheme: dark) supports(color: oklch(0.5 0.2 150deg));', lang: 'css', caption: '条件导入让样式按需加载' },
      { type: 'tip', text: '浏览器可以在条件不匹配时**跳过加载**资源——如果用户访问桌面端，`mobile.css` 根本不会下载，节省带宽。' },
      { type: 'heading', text: '层叠层：控制导入样式的优先级' },
      { type: 'paragraph', text: 'CSS Cascade 5 新增了 `layer` 关键字，允许将导入的样式表分配到指定的**层叠层**（cascade layer）。这让你可以精确控制导入样式的优先级，避免特异性竞赛。' },
      { type: 'code', code: '/* 将导入的样式分配到层 */\n@import "reset.css" layer(reset);\n@import "framework.css" layer(framework);\n@import "components.css" layer(components);\n\n/* 自定义样式在隐式的最终层，优先级最高 */\nbutton {\n  background: blue; /* 会覆盖 framework.css 中的按钮样式 */\n}', lang: 'css', caption: '使用层叠层组织导入的样式' },
      { type: 'heading', text: '层叠来源：继承导入者的来源' },
      { type: 'paragraph', text: '导入的样式表的**层叠来源**（cascade origin）与导入它的样式表相同。如果在作者样式表中导入，导入的样式也是作者来源；如果在用户样式表中导入，导入的样式也是用户来源。这确保了来源边界的清晰性。' },
      { type: 'code', code: '/* 作者样式表 (author origin) */\n@import "theme.css";  /* theme.css 的规则也是作者来源 */\n\n/* 用户样式表 (user origin) */\n@import "accessibility.css";  /* accessibility.css 的规则是用户来源 */', lang: 'css' },
      { type: 'heading', text: '多次导入与缓存' },
      { type: 'paragraph', text: '如果同一个样式表在多处被导入，浏览器**必须将每次链接视为独立样式表**——内容会多次参与层叠，就像你复制粘贴了多份。但浏览器可以缓存资源，避免重复下载。' },
      { type: 'example', title: '同一文件被多次导入', code: '/* main.css */\n@import "reset.css";  /* 第 1 次导入 */\n@import "reset.css";  /* 第 2 次导入，规则会重复参与层叠 */\n\n/* 等效于 */\n/* reset.css 的内容 (第 1 份) */\n/* reset.css 的内容 (第 2 份) */', lang: 'css', explanation: 'reset.css 的规则会出现两次，但浏览器只会下载一次文件（通过 HTTP 缓存）。' },
      { type: 'warning', text: '多次导入会增加层叠计算成本——如果一个样式表被导入 10 次，它的规则在层叠排序中会出现 10 份。尽量避免重复导入。' },
      { type: 'heading', text: '编码环境与 Content-Type' },
      { type: 'paragraph', text: '导入的样式表的**编码环境**（environment encoding）继承自导入它的样式表——如果父样式表是 UTF-8，导入的样式表也应该是 UTF-8。资源的 HTTP `Content-Type` 头必须是 `text/css`，否则浏览器会拒绝解析，视为网络错误。' },
      { type: 'code', code: '/* 服务器必须返回正确的 Content-Type */\nContent-Type: text/css; charset=utf-8  /* ✓ 正确 */\nContent-Type: text/plain               /* ❌ 错误，不会被解析 */', lang: 'http' },
      { type: 'tip', text: '现代构建工具（Webpack、Vite）通常会将 `@import` 在构建时内联，生成单个 CSS 文件。这避免了多次 HTTP 请求，但也意味着导入条件在构建时就确定了。' },
      { type: 'list', items: [
        '`@import` 必须在样式表最前面（除了 `@charset` 和 `@layer` 声明）',
        '导入的样式表被视为在 `@import` 位置展开',
        '支持媒体查询和特性检测条件',
        '可以通过 `layer()` 将导入的样式分配到层叠层',
        '导入的样式表继承父样式表的层叠来源',
        '同一文件多次导入会重复参与层叠（但可以被缓存）'
      ] },
    ] as TutorialBlock[],
  },
  {
    id: 'shorthand',
    number: '3',
    title: { zh: '简写属性', en: 'Shorthand Properties' },
    summary: { zh: '简写属性允许同时设置多个相关属性的值。未指定的子属性会被重置为初始值。', en: 'Shorthand properties allow setting multiple related property values simultaneously. Unspecified sub-properties are reset to initial values.' },
    keyPoints: [
      '简写属性会重置所有子属性,未指定的子属性被设为初始值',
      'all 属性可以重置几乎所有 CSS 属性(direction 和 unicode-bidi 除外),但不影响自定义属性',
      '使用简写时要注意意外重置:如 background: green 会重置 background-image 为 none',
      '简写属性设为 CSS 全局关键字(initial/inherit/unset/revert)时,所有子属性都设为该关键字',
      '声明简写属性为 !important 等价于声明其所有子属性为 !important',
      '某些子属性是"仅重置子属性"(reset-only sub-property):被简写重置为初始值,但简写无语法设置其他值,如 border 会重置 border-image',
      '属性别名(aliasing)分为两种:legacy name alias(解析时名称转换)和 legacy shorthand(作为简写映射)',
      '简写属性有时有特殊语法或关键字,不直接对应子属性值,此时简写会显式定义展开方式',
      'all 属性仅接受 CSS 全局关键字;设为 initial 时会阻断所有继承并重置所有属性',
    ],
    tutorial: [
      { type: 'heading', text: '简写属性：一次设置多个值' },
      { type: 'paragraph', text: '**简写属性**（shorthand property）允许你一次性设置多个相关的**子属性**（sub-property 或 longhand property）。例如 `margin` 可以同时设置 `margin-top`、`margin-right`、`margin-bottom`、`margin-left` 四个子属性。简写属性是 CSS 的便利特性，让代码更简洁，但也有重要的隐式行为需要理解。' },
      { type: 'code', code: '/* 简写属性 */\nmargin: 10px 20px;  /* 同时设置 4 个子属性 */\n\n/* 等价于子属性 */\nmargin-top: 10px;\nmargin-right: 20px;\nmargin-bottom: 10px;\nmargin-left: 20px;', lang: 'css', caption: '简写属性展开为子属性' },
      { type: 'heading', text: '核心规则：未指定的子属性会被重置' },
      { type: 'paragraph', text: '这是简写属性最重要的行为：**未指定的子属性会被重置为初始值**。即使你只想设置一个子属性，简写属性也会重置所有其他子属性。这是导致 CSS 样式「莫名消失」的常见原因。' },
      { type: 'example', title: '意外重置：background 简写的陷阱', code: '.box {\n  background-image: url("pattern.png");\n  background-color: lightblue;\n}\n\n/* 后来添加了这行 */\n.box {\n  background: white;  /* ❌ 重置了 background-image 为 none！ */\n}', lang: 'css', explanation: '`background: white` 展开为所有 background-* 子属性，包括 `background-image: none`，导致背景图消失。' },
      { type: 'code', code: '/* 正确做法：只设置需要的子属性 */\n.box {\n  background-image: url("pattern.png");\n  background-color: white;  /* ✓ 只改颜色，不影响背景图 */\n}', lang: 'css', caption: '需要精确控制时，使用子属性' },
      { type: 'heading', text: '常见简写属性及其子属性' },
      { type: 'list', items: [
        '**margin/padding**：`-top`、`-right`、`-bottom`、`-left` 四个方向',
        '**border**：`-width`、`-style`、`-color` 三个维度 × 4 个方向 = 12 个子属性',
        '**background**：`-color`、`-image`、`-position`、`-size`、`-repeat`、`-origin`、`-clip`、`-attachment` 共 8 个',
        '**font**：`-style`、`-variant`、`-weight`、`-size`、`line-height`、`-family` 共 6 个',
        '**animation**：`-name`、`-duration`、`-timing-function`、`-delay`、`-iteration-count`、`-direction`、`-fill-mode`、`-play-state` 共 8 个',
        '**transition**：`-property`、`-duration`、`-timing-function`、`-delay` 共 4 个'
      ] },
      { type: 'heading', text: '仅重置子属性：隐藏的重置行为' },
      { type: 'paragraph', text: '某些子属性是**仅重置子属性**（reset-only sub-property）——它们会被简写重置为初始值，但简写的语法**无法将其设为其他值**。最典型的例子是 `border-image`：`border` 简写会将其重置为 `none`，但你无法通过 `border` 简写设置 `border-image`。' },
      { type: 'example', title: 'border 重置 border-image', code: '.box {\n  border-image: url("border.png") 30 round;\n}\n\n.box {\n  border: 2px solid black;  /* 重置 border-image 为 none */\n}\n\n/* 结果：边框图消失，只有纯色边框 */', lang: 'css', explanation: '`border` 简写重置了 `border-image`，即使你没有显式设置它。' },
      { type: 'tip', text: '如果你使用了 `border-image`，之后要修改边框样式时，使用子属性（`border-width`、`border-style`、`border-color`）而不是简写 `border`。' },
      { type: 'heading', text: '全局关键字：一次设置所有子属性' },
      { type: 'paragraph', text: '当简写属性被设为 CSS 全局关键字（`initial`、`inherit`、`unset`、`revert`、`revert-layer`）时，**所有子属性都会被设为该关键字**。这是批量重置或继承属性的便捷方式。' },
      { type: 'code', code: '/* 批量重置所有 margin 子属性为初始值 */\nmargin: initial;  /* 等价于所有方向 margin 都是 0 */\n\n/* 批量强制继承 */\nborder: inherit;  /* 所有 border-* 子属性都从父元素继承 */', lang: 'css' },
      { type: 'heading', text: '!important 会传递给所有子属性' },
      { type: 'paragraph', text: '对简写属性声明 `!important` 等价于对其**所有子属性**声明 `!important`。这会让所有子属性在层叠中获得最高优先级。' },
      { type: 'code', code: '.box {\n  margin: 0 !important;\n}\n\n/* 等价于 */\n.box {\n  margin-top: 0 !important;\n  margin-right: 0 !important;\n  margin-bottom: 0 !important;\n  margin-left: 0 !important;\n}', lang: 'css', caption: '!important 传递给所有子属性' },
      { type: 'warning', text: '滥用 `!important` 会让样式难以覆盖。如果你发现自己频繁使用 `!important`，可能是层叠结构或选择器特异性设计有问题。' },
      { type: 'heading', text: 'all 属性：终极简写' },
      { type: 'paragraph', text: '`all` 是最特殊的简写属性——它可以重置**几乎所有 CSS 属性**（除了 `direction` 和 `unicode-bidi`）。`all` 只接受全局关键字，常用于隔离组件样式或重置继承。' },
      { type: 'code', code: '/* 重置组件的所有样式 */\n.isolated-widget {\n  all: initial;  /* 所有属性重置为初始值，阻断继承 */\n}\n\n/* 强制继承所有可继承属性 */\n.inherit-all {\n  all: inherit;  /* 所有属性都从父元素继承 */\n}\n\n/* 回滚到浏览器默认样式 */\n.reset-to-ua {\n  all: revert;  /* 忽略作者样式，回到 UA 样式 */\n}', lang: 'css', caption: 'all 属性的典型用法' },
      { type: 'tip', text: '`all: initial` 是创建「干净房间」的利器——在 Web Components 或 iframe 中使用，可以完全隔离外部样式的影响。' },
      { type: 'warning', text: '`all` 不影响自定义属性（CSS 变量）——`all: initial` 不会重置 `--my-var`。' },
      { type: 'heading', text: '简写的特殊语法' },
      { type: 'paragraph', text: '某些简写属性有特殊语法或关键字，不是简单的子属性值列表。例如 `background` 的 `background-size` 必须跟在 `background-position` 后面，用斜杠分隔；`font` 的 `line-height` 必须跟在 `font-size` 后面，也用斜杠分隔。' },
      { type: 'code', code: '/* background-size 必须跟在 background-position 后 */\nbackground: url("bg.png") center / cover;  /* position / size */\n\n/* line-height 必须跟在 font-size 后 */\nfont: bold 16px/1.5 Arial;  /* size/line-height family */', lang: 'css', caption: '简写属性的特殊语法规则' },
      { type: 'list', items: [
        '简写属性会重置**所有**子属性，包括你没有指定的',
        '使用简写前要确认是否会意外重置其他子属性',
        '仅重置子属性（如 `border-image`）会被简写重置但无法通过简写设置',
        '全局关键字和 `!important` 会应用到所有子属性',
        '`all` 属性可以一次重置几乎所有 CSS 属性',
        '需要精确控制时，使用子属性而非简写'
      ] },
    ] as TutorialBlock[],
  },
  {
    id: 'value-stages',
    number: '4',
    title: { zh: '值的处理', en: 'Value Processing' },
    summary: { zh: '从声明值到实际值的完整流程:declared → cascaded → specified → computed → used → actual', en: 'The complete process from declared value to actual value: declared → cascaded → specified → computed → used → actual' },
    keyPoints: [
      'Declared Value(声明值): 所有适用于某元素某属性的声明值的集合,可能有零个或多个',
      'Cascaded Value(层叠值): 层叠排序后胜出的那个声明值,每个属性最多一个层叠值',
      'Specified Value(指定值): 层叠值经过默认处理后的值;每个元素的每个属性恰好有一个指定值',
      'Computed Value(计算值): 将指定值中的相对值(em、百分比、URL 等)尽可能解析为绝对值,不依赖布局;这是继承时传递的值',
      'Used Value(使用值): 将计算值完成所有剩余计算(如百分比宽度需要包含块尺寸)后的绝对理论值;不适用的属性没有使用值',
      'Actual Value(实际值): 使用值经过环境限制(可用字体、整数像素宽度等)调整后的最终渲染值',
      'getComputedStyle() 由于历史原因有时返回使用值而非计算值(如 width 返回像素值)',
      '某些属性的值有 legacy value alias(历史值别名):解析时旧语法自动转换为新语法,产生不同的声明值',
      '属性即使不适用于某元素,其计算值仍然存在,且可继承给后代生效(如对不适用元素设置 text-transform 仍会继承到内联子元素)',
      '"适用于所有元素"的属性适用于所有元素和显示类型,但不一定适用于所有伪元素(::before/::after 除外)',
    ],
    tutorial: [
      { type: 'heading', text: '值的六个处理阶段' },
      { type: 'paragraph', text: 'CSS 规范定义了属性值从声明到最终渲染的**六个处理阶段**：声明值 → 层叠值 → 指定值 → 计算值 → 使用值 → 实际值。每个阶段都有明确的计算规则和职责。理解这个流程能帮助你理解 CSS 的行为逻辑——为什么 `em` 会转换为像素、为什么 `inherit` 能获取父元素的值、为什么 `getComputedStyle()` 有时返回「奇怪」的值。' },
      { type: 'code', code: '/* 值处理流程示例 */\np {\n  font-size: 16px;         /* 父元素 */\n}\n\nspan {\n  font-size: 1.5em;        /* 声明值: 1.5em */\n  /* ↓ 层叠后仍是 1.5em */\n  /* ↓ 指定值: 1.5em */\n  /* ↓ 计算值: 24px (1.5 × 16px) */\n  /* ↓ 使用值: 24px */\n  /* ↓ 实际值: 24px */\n}', lang: 'css', caption: '一个值的完整处理流程' },
      { type: 'heading', text: '阶段 1：声明值（Declared Value）' },
      { type: 'paragraph', text: '**声明值**是所有适用于某元素某属性的声明值的**集合**——可能有零个、一个或多个。这是层叠处理的输入。声明值来自所有匹配该元素的样式规则（作者、用户、UA 样式表）。' },
      { type: 'example', title: '同一属性有多个声明值', code: '/* 三条规则都匹配 <p class="intro" id="first"> */\np { color: blue; }           /* 声明值 1 */\n.intro { color: red; }       /* 声明值 2 */\n#first { color: green; }     /* 声明值 3 */\n\n/* color 属性的声明值集合: [blue, red, green] */', lang: 'css', explanation: '这三个声明值会进入层叠排序，最终只有一个胜出。' },
      { type: 'heading', text: '阶段 2：层叠值（Cascaded Value）' },
      { type: 'paragraph', text: '**层叠值**是层叠排序后**胜出**的那个声明值。每个属性最多有一个层叠值（如果没有任何声明，则该属性没有层叠值）。层叠按来源、重要性、特异性、顺序排序，第 6 节会详细讲解。' },
      { type: 'code', code: '/* 接上例，层叠排序后 */\n#first { color: green; }  /* ID 选择器特异性最高，green 胜出 */\n\n/* color 属性的层叠值: green */', lang: 'css', caption: '层叠值 = 胜出的声明值' },
      { type: 'heading', text: '阶段 3：指定值（Specified Value）' },
      { type: 'paragraph', text: '**指定值**是层叠值经过**默认处理**（defaulting）后的值。如果有层叠值，指定值就是层叠值；如果没有层叠值，通过继承或初始值确定。每个元素的每个属性**恰好有一个**指定值——这是 CSS 值处理的重要保证。' },
      { type: 'list', items: [
        '如果有层叠值 → 指定值 = 层叠值',
        '如果无层叠值且属性可继承 → 指定值 = 父元素的计算值',
        '如果无层叠值且属性不可继承 → 指定值 = 初始值'
      ] },
      { type: 'example', title: '通过继承获得指定值', code: '<div style="color: navy;">  <!-- color 计算值: navy -->\n  <p>这段文字</p>  <!-- 无层叠值，继承得到指定值: navy -->\n</div>', lang: 'html', explanation: '`<p>` 的 `color` 属性没有声明，通过继承获得指定值 `navy`。' },
      { type: 'heading', text: '阶段 4：计算值（Computed Value）' },
      { type: 'paragraph', text: '**计算值**将指定值中的**相对值**尽可能解析为绝对值——`em` 转为像素、相对 URL 转为绝对 URL、某些关键字转为具体值。关键限制：计算值的生成**不依赖布局**（不需要包含块尺寸、不需要渲染树）。计算值是**继承时传递的值**——子元素继承父元素的计算值，而非指定值或使用值。' },
      { type: 'code', code: '/* 计算值示例 */\n.parent {\n  font-size: 16px;           /* 计算值: 16px */\n  width: 50%;                /* 计算值: 50% (保留百分比) */\n  line-height: 1.5;          /* 计算值: 1.5 (保留无单位数) */\n  color: currentColor;       /* 计算值: rgb(0, 0, 255) (解析关键字) */\n}\n\n.child {\n  font-size: 2em;            /* 指定值: 2em → 计算值: 32px (2 × 16px) */\n}', lang: 'css', caption: 'em 单位被解析，百分比保留' },
      { type: 'tip', text: '为什么 `width: 50%` 的计算值保留百分比？因为百分比相对于包含块宽度，而包含块宽度依赖布局——计算值阶段还不知道布局信息。' },
      { type: 'heading', text: '阶段 5：使用值（Used Value）' },
      { type: 'paragraph', text: '**使用值**将计算值完成**所有剩余计算**——百分比需要包含块尺寸、`auto` 需要布局算法、内在尺寸需要图片加载完成。使用值是**绝对的理论值**，已经可以用于渲染，但可能不是整数或可用值。不适用的属性没有使用值（如行内元素的 `width`）。' },
      { type: 'code', code: '/* 使用值示例（假设包含块宽度 800px）*/\n.box {\n  width: 50%;       /* 计算值: 50% → 使用值: 400px */\n  height: auto;     /* 计算值: auto → 使用值: 120px (布局算法计算) */\n  margin: 0 auto;   /* 计算值: 0 auto → 使用值: 0 200px (auto 计算为具体值) */\n}', lang: 'css', caption: '使用值是布局后的绝对值' },
      { type: 'heading', text: '阶段 6：实际值（Actual Value）' },
      { type: 'paragraph', text: '**实际值**是使用值经过**环境限制**调整后的最终渲染值。环境限制包括：屏幕只能渲染整数像素（`12.7px` → `13px`）、字体可能不可用（降级到其他字体）、颜色可能需要量化到有限色彩空间。实际值是浏览器真正用于绘制的值。' },
      { type: 'example', title: '实际值的环境调整', code: '.box {\n  width: 100.7px;   /* 使用值: 100.7px → 实际值: 101px (整数像素) */\n  font-family: "MyFont", Arial;\n  /* 使用值: MyFont → 实际值: Arial (MyFont 不可用时降级) */\n}', lang: 'css', explanation: '实际值受设备能力限制——屏幕不支持亚像素宽度，字体可能缺失。' },
      { type: 'heading', text: 'getComputedStyle() 的历史问题' },
      { type: 'paragraph', text: 'JavaScript 的 `getComputedStyle()` API 理论上应该返回**计算值**，但由于历史原因，某些属性返回的是**使用值**。最典型的是 `width` 和 `height`——即使你设置了 `width: 50%`，`getComputedStyle()` 也会返回像素值（如 `400px`）而非百分比。' },
      { type: 'code', code: '/* HTML */\n<div style="width: 50%;"></div>\n\n/* JavaScript */\nconst div = document.querySelector(\'div\');\nconst style = getComputedStyle(div);\nconsole.log(style.width);  // "400px" (使用值) 而非 "50%" (计算值)', lang: 'javascript', caption: 'getComputedStyle() 有时返回使用值' },
      { type: 'warning', text: '不要依赖 `getComputedStyle()` 的返回值格式——它可能是计算值或使用值，取决于具体属性。如果需要原始声明值，检查元素的 `style` 属性。' },
      { type: 'heading', text: '属性的「适用性」与计算值' },
      { type: 'paragraph', text: '某些属性对某些元素不适用（如 `width` 对行内非替换元素不适用），但这不影响计算值的存在——**所有元素的所有属性都有计算值**，即使属性不适用。不适用的属性只是没有使用值和实际值（不参与渲染），但计算值仍然存在，且可以继承给后代。' },
      { type: 'example', title: '不适用属性的继承', code: '<span style="width: 200px;">  <!-- width 对 span 不适用 -->\n  <img src="photo.jpg">  <!-- 但 img 可以继承 width: 200px -->\n</span>', lang: 'html', explanation: '`span` 的 `width` 计算值是 `200px`，虽然对 `span` 不适用，但可以继承给 `img`（对 `img` 适用）。' },
      { type: 'list', items: [
        '**声明值**：所有匹配的声明的集合（输入）',
        '**层叠值**：层叠排序后胜出的声明值',
        '**指定值**：层叠值或默认处理（继承/初始值）后的值',
        '**计算值**：相对值尽可能解析为绝对值（不依赖布局）',
        '**使用值**：完成所有计算的绝对值（依赖布局）',
        '**实际值**：经过环境限制调整后的最终渲染值'
      ] },
      { type: 'tip', text: '继承传递的是**计算值**——父元素的计算值成为子元素的指定值（如果子元素没有声明）。这确保了继承的稳定性。' },
    ] as TutorialBlock[],
  },
  {
    id: 'filtering',
    number: '5',
    title: { zh: '过滤', en: 'Filtering' },
    summary: { zh: '确定哪些声明适用于哪些元素。声明必须来自适用的样式表、匹配的选择器、有效的语法。', en: 'Determines which declarations apply to which elements. Declarations must come from applicable stylesheets, matching selectors, and valid syntax.' },
    keyPoints: [
      '样式表必须当前适用于文档(如 <link> 的 media 属性匹配)',
      '条件规则(@media, @supports)的条件必须为真,否则其中的声明不适用',
      '声明所属的样式规则的选择器必须匹配该元素(需考虑作用域 scoping)',
      '声明语法必须有效:属性名为已知属性,且值匹配该属性的语法定义',
      '过滤后得到的适用声明值构成每个元素每个属性的声明值列表(declared values list)',
      '声明值列表是层叠(cascade)处理的输入,由层叠进行优先级排序',
      '不满足任何一条过滤条件的声明将被完全忽略,不参与后续层叠',
      '对于特定媒体类型不适用的样式表中的所有声明都会被过滤掉',
      '过滤阶段区分于层叠阶段:过滤决定"哪些声明适用",层叠决定"哪个声明胜出"',
    ],
    tutorial: [
      { type: 'heading', text: '过滤：第一道门槛' },
      { type: 'paragraph', text: '在层叠排序之前，CSS 会先进行**过滤**（filtering）——确定哪些声明**适用于**（apply to）哪些元素。过滤是一个严格的筛选过程，只有通过所有检查的声明才能进入后续的层叠处理。过滤失败的声明会被完全忽略，就像它们不存在一样。' },
      { type: 'list', ordered: true, items: [
        '样式表必须当前适用于文档',
        '条件规则的条件必须为真',
        '选择器必须匹配该元素',
        '声明语法必须有效'
      ] },
      { type: 'heading', text: '条件 1：样式表必须适用' },
      { type: 'paragraph', text: '样式表通过 `<link>` 或 `@import` 引入时，可以指定**媒体条件**（media condition）。只有媒体条件匹配当前环境时，样式表才适用。不适用的样式表中的**所有声明**都会被过滤掉。' },
      { type: 'example', title: '媒体条件不匹配的样式表', code: '<!-- 只在打印时适用 -->\n<link rel="stylesheet" href="print.css" media="print">\n\n<!-- 在屏幕上浏览时，print.css 中的所有声明都被过滤掉 -->', lang: 'html', explanation: '媒体条件 `media="print"` 不匹配屏幕媒体，整个样式表被忽略。' },
      { type: 'code', code: '/* 样式表内的条件导入 */\n@import "mobile.css" (max-width: 768px);\n\n/* 在宽屏设备上，mobile.css 的所有声明都被过滤掉 */', lang: 'css' },
      { type: 'heading', text: '条件 2：条件规则必须为真' },
      { type: 'paragraph', text: '样式表中的条件规则（如 `@media`、`@supports`、`@container`）必须条件为真，其中的声明才适用。条件为假时，**块内的所有声明**都被过滤掉。' },
      { type: 'code', code: '/* 媒体查询条件 */\n@media (max-width: 768px) {\n  .sidebar { display: none; }  /* 仅在窄屏时适用 */\n}\n\n/* 特性检测条件 */\n@supports (display: grid) {\n  .layout { display: grid; }   /* 仅在支持 Grid 时适用 */\n}\n\n/* 容器查询条件 */\n@container (min-width: 400px) {\n  .card { flex-direction: row; }  /* 仅在容器宽度≥400px时适用 */\n}', lang: 'css', caption: '条件为真时声明才适用' },
      { type: 'tip', text: '条件规则可以嵌套——内层规则必须所有外层条件都为真时才会被检查。`@media screen { @supports (grid) { ... } }` 需要屏幕媒体**且**支持 Grid。' },
      { type: 'heading', text: '条件 3：选择器必须匹配' },
      { type: 'paragraph', text: '声明所属的样式规则的**选择器**必须匹配该元素，声明才适用于该元素。选择器匹配考虑元素的标签名、类名、ID、属性、伪类、伪元素和文档树关系。作用域（`@scope`）也会影响匹配。' },
      { type: 'example', title: '选择器匹配与不匹配', code: '/* CSS */\np { color: blue; }        /* 匹配所有 <p> */\n.intro { color: red; }    /* 匹配所有 class="intro" */\n#first { color: green; }  /* 匹配 id="first" */\n\n<!-- HTML -->\n<p>蓝色</p>                    <!-- 匹配 p 选择器 -->\n<p class="intro">红色</p>      <!-- 匹配 p 和 .intro 选择器 -->\n<div class="intro">红色</div>  <!-- 只匹配 .intro 选择器 -->\n<span>黑色</span>              <!-- 不匹配任何选择器，使用继承或初始值 -->', lang: 'html', explanation: '只有选择器匹配的规则才会为该元素贡献声明值。' },
      { type: 'heading', text: '条件 4：声明语法必须有效' },
      { type: 'paragraph', text: '声明的语法必须有效——**属性名必须是已知属性**，**值必须匹配该属性的语法定义**。语法无效的声明会被解析器忽略，不参与层叠。这是 CSS 的**容错机制**——浏览器遇到不认识的语法时会跳过，而不是报错。' },
      { type: 'code', code: '/* 有效声明 */\ncolor: red;              /* ✓ 已知属性 + 合法值 */\nwidth: 100px;            /* ✓ */\ndisplay: flex;           /* ✓ */\n\n/* 无效声明（会被忽略）*/\ncolour: red;             /* ❌ 属性名拼写错误 */\ncolor: 100px;            /* ❌ color 不接受长度值 */\ndisplay: flexbox;        /* ❌ display 没有 flexbox 值（应该是 flex）*/\nwidth: red;              /* ❌ width 不接受颜色值 */', lang: 'css', caption: '无效声明被静默忽略' },
      { type: 'warning', text: '拼写错误是 CSS 调试的常见陷阱——浏览器不会报错，样式只是「不生效」。使用开发者工具检查声明是否被划掉（表示无效）。' },
      { type: 'heading', text: '过滤的结果：声明值列表' },
      { type: 'paragraph', text: '经过过滤后，每个元素的每个属性会得到一个**声明值列表**（declared values list）——所有通过过滤的声明值的集合。这个列表是层叠处理的输入。列表可能为空（没有声明）、有一个值（只有一条规则）或多个值（多条规则）。' },
      { type: 'example', title: '声明值列表示例', code: '/* CSS */\np { color: blue; }           /* 声明 1 */\n.intro { color: red; }       /* 声明 2 */\n@media print {\n  p { color: black; }        /* 声明 3（仅在打印时）*/\n}\n\n<!-- HTML（屏幕媒体）-->\n<p class="intro">文本</p>\n\n/* 这个 <p> 的 color 属性的声明值列表: [blue, red] */\n/* 声明 3 因为媒体条件不匹配而被过滤掉 */', lang: 'css', explanation: '声明值列表只包含通过过滤的声明。' },
      { type: 'heading', text: '过滤 vs 层叠：两个独立阶段' },
      { type: 'paragraph', text: '过滤和层叠是两个独立的阶段，职责不同：**过滤决定「哪些声明适用」**，**层叠决定「哪个声明胜出」**。过滤是「入场券」检查——不通过就进不去；层叠是「竞赛排名」——通过的声明按规则排序，最高分胜出。' },
      { type: 'code', code: '/* 过滤阶段 */\n样式表适用？ → 条件为真？ → 选择器匹配？ → 语法有效？\n         ↓                              ↓\n      被忽略                     进入声明值列表\n                                      ↓\n/* 层叠阶段 */\n按来源、重要性、特异性、顺序排序 → 选出胜者 → 层叠值', lang: 'text', caption: '过滤 + 层叠的两阶段流程' },
      { type: 'tip', text: '调试时先确认声明是否通过过滤——开发者工具会显示被忽略的声明（灰色或划线）。如果声明根本没出现，检查选择器是否匹配、媒体查询是否匹配。' },
      { type: 'list', items: [
        '过滤是层叠之前的筛选阶段，决定声明是否适用',
        '四个过滤条件：样式表适用、条件为真、选择器匹配、语法有效',
        '不通过过滤的声明被完全忽略，不参与层叠',
        '过滤的结果是每个元素每个属性的声明值列表',
        '过滤决定「谁能参赛」，层叠决定「谁是冠军」'
      ] },
    ] as TutorialBlock[],
  },
  {
    id: 'cascading',
    number: '6',
    title: { zh: '层叠', en: 'Cascading' },
    summary: { zh: '当多个声明作用于同一属性时,按来源、重要性、特异性、顺序决定最终值。', en: 'When multiple declarations affect the same property, the final value is determined by origin, importance, specificity, and order.' },
    keyPoints: [
      '层叠排序依据(按优先级递减):来源与重要性 → 封装上下文 → 元素附属样式 → 层叠层 → 特异性 → 出现顺序',
      '来源优先级:Transition > !important UA > !important User > !important Author > Animation > Author > User > UA',
      '封装上下文(encapsulation context):Shadow DOM 等嵌套上下文中,普通规则外层优先,!important 规则内层优先',
      '元素附属样式(如 style 属性)在同来源同重要性下优先于选择器匹配的规则',
      'CSS Cascade 5 新增层叠层(@layer):同来源同上下文内可显式分层;普通规则后声明的层优先,!important 规则先声明的层优先',
      '未分配到显式层的规则被加入隐式最终层(implicit final layer),优先级高于所有显式层',
      '特异性:(ID, Class, Type) 三元组比较;相同来源、重要性、层级的声明按特异性排序',
      '出现顺序:以上条件都相同时,后声明的优先;@import 的声明视为在导入位置展开',
      '!important 的设计目的是平衡作者与用户样式表的权力:用户 !important 可覆盖作者 !important',
      '表现性提示(presentational hints)如 HTML 的 bgcolor 属性,被转换为 CSS 规则进入 UA 来源或特殊的作者表现性提示来源',
    ],
    tutorial: [
      { type: 'heading', text: '层叠：CSS 的核心算法' },
      { type: 'paragraph', text: '**层叠**（cascade）是 CSS 名字中的 "C"——当多个声明作用于同一元素的同一属性时，层叠机制决定**哪个声明胜出**。层叠是一个多级排序算法，按优先级依次比较：来源与重要性 → 封装上下文 → 元素附属样式 → 层叠层 → 特异性 → 出现顺序。理解层叠是掌握 CSS 的关键——它解释了为什么你的样式会「生效」或「不生效」。' },
      { type: 'heading', text: '层叠排序的六个维度' },
      { type: 'list', ordered: true, items: [
        '**来源与重要性**（Origin and Importance）：样式来自哪里（作者/用户/UA），是否有 `!important`',
        '**封装上下文**（Encapsulation Context）：Shadow DOM 等嵌套上下文的层级',
        '**元素附属样式**（Element-Attached Styles）：内联样式（`style` 属性）vs 选择器样式',
        '**层叠层**（Cascade Layers）：`@layer` 规则定义的显式层级',
        '**特异性**（Specificity）：选择器的权重（ID、class、标签）',
        '**出现顺序**（Order of Appearance）：声明在样式表中的位置'
      ] },
      { type: 'paragraph', text: '层叠按这六个维度依次比较——先比较来源与重要性，相同则比较封装上下文，相同则比较元素附属样式，以此类推。一旦某个维度分出高低，就不再比较后续维度。' },
      { type: 'heading', text: '维度 1：来源与重要性' },
      { type: 'paragraph', text: '样式有三个**来源**（origin）：**作者**（author，网站开发者）、**用户**（user，浏览网页的人）、**用户代理**（user agent，浏览器默认样式）。每个来源的声明可以标记 `!important`，成为**重要声明**。层叠优先级：' },
      { type: 'code', code: '/* 层叠来源优先级（从高到低）*/\n1. Transition（过渡动画产生的值，最高优先级）\n2. !important User Agent（浏览器的重要声明）\n3. !important User（用户的重要声明）\n4. !important Author（作者的重要声明）\n5. Animation（@keyframes 动画产生的值）\n6. Author（作者的普通声明）  ← 我们写的 CSS 通常在这里\n7. User（用户的普通声明）\n8. User Agent（浏览器的普通声明，最低优先级）', lang: 'text', caption: '来源优先级排序' },
      { type: 'tip', text: '注意 `!important` 的顺序反转——普通声明中作者优先级最高，但重要声明中用户优先级最高。这是为了保护用户的无障碍需求：用户可以用 `!important` 覆盖作者的任何样式。' },
      { type: 'example', title: '!important 的来源优先级', code: '/* 用户样式表 */\n* { font-size: 24px !important; }  /* 用户需要大字号 */\n\n/* 作者样式表 */\nbody { font-size: 16px !important; }  /* 作者的 !important 无法覆盖用户的 */\n\n/* 结果：字号是 24px（用户的 !important 胜出）*/', lang: 'css', explanation: '用户的重要声明优先级高于作者的重要声明，保护用户自主权。' },
      { type: 'heading', text: '维度 2：封装上下文' },
      { type: 'paragraph', text: '**封装上下文**（encapsulation context）是指 Shadow DOM 等机制创建的样式隔离边界。在嵌套上下文中，**普通规则外层上下文优先**（让外部样式可以影响内部），**重要规则内层上下文优先**（让内部组件可以保护关键样式）。' },
      { type: 'code', code: '/* 外层文档 */\n.widget { color: blue; }\n.widget { color: red !important; }\n\n/* Shadow DOM 内部 */\n:host { color: green; }\n:host { color: yellow !important; }\n\n/* 结果：\n   color: blue（外层普通规则优先）\n   但如果有 !important，则 color: yellow（内层重要规则优先）*/', lang: 'css', caption: '封装上下文的层叠顺序' },
      { type: 'heading', text: '维度 3：元素附属样式' },
      { type: 'paragraph', text: '**元素附属样式**（element-attached styles）指通过元素的 `style` 属性（内联样式）声明的样式。在同来源、同重要性下，内联样式优先级高于选择器样式。' },
      { type: 'example', title: '内联样式优先级', code: '/* CSS */\n#myDiv { color: red !important; }  /* ID 选择器 + !important */\n\n<!-- HTML -->\n<div id="myDiv" style="color: blue;">文本</div>\n\n/* 结果：color: blue（内联样式在同重要性下优先）*/', lang: 'html', explanation: '内联样式的层级高于选择器样式，但仍受来源和重要性控制。' },
      { type: 'warning', text: '过度使用内联样式会破坏样式的集中管理——样式分散在 HTML 中，难以维护和覆盖。尽量用 class 而非内联样式。' },
      { type: 'heading', text: '维度 4：层叠层（@layer）' },
      { type: 'paragraph', text: 'CSS Cascade 5 新增了**层叠层**（cascade layers）机制，允许你显式地将样式规则组织到不同的层中。层的声明顺序决定优先级：**普通规则后声明的层优先，重要规则先声明的层优先**（顺序反转）。' },
      { type: 'code', code: '/* 声明层的顺序 */\n@layer reset, base, components, utilities;\n\n@layer reset {\n  * { margin: 0; }  /* 优先级最低（普通规则）*/\n}\n\n@layer utilities {\n  .m-0 { margin: 0; }  /* 优先级最高（普通规则）*/\n}\n\n/* 未分配到显式层的规则 */\n.custom { margin: 1em; }  /* 隐式最终层，优先级最高 */', lang: 'css', caption: '层叠层按声明顺序排序' },
      { type: 'tip', text: '未分配到显式层的规则被放入**隐式最终层**（implicit final layer），优先级高于所有显式层。这让你可以在定义完框架层后，自由添加自定义样式覆盖它们。' },
      { type: 'example', title: '!important 在层中的顺序反转', code: '@layer A, B;\n\n@layer A {\n  p { color: red !important; }  /* 优先级高（重要规则先声明）*/\n}\n\n@layer B {\n  p { color: blue !important; }  /* 优先级低 */\n}\n\n/* 结果：color: red（层 A 的重要规则优先）*/', lang: 'css', explanation: '重要规则中，先声明的层优先级更高——与普通规则相反。' },
      { type: 'heading', text: '维度 5：特异性' },
      { type: 'paragraph', text: '**特异性**（specificity）是选择器的权重，用三元组 `(ID, Class, Type)` 表示。比较时从左到右依次比较——ID 数量相同再比较 class 数量，class 数量相同再比较标签数量。' },
      { type: 'code', code: '/* 特异性计算 */\n#id { }                  /* (1, 0, 0) */\n.class { }               /* (0, 1, 0) */\ndiv { }                  /* (0, 0, 1) */\n#id .class div { }       /* (1, 1, 1) */\n.class.class.class { }   /* (0, 3, 0) 三个 class 胜过一个 ID？不！*/\n#id { }                  /* (1, 0, 0) 一个 ID 胜出 */', lang: 'css', caption: '特异性三元组比较' },
      { type: 'warning', text: '特异性不是十进制——`(0, 11, 0)` 不等于 `(1, 1, 0)`。比较时只看每个位置的数字，11 个 class 永远赢不过 1 个 ID。' },
      { type: 'heading', text: '维度 6：出现顺序' },
      { type: 'paragraph', text: '当所有前述条件都相同时，**后声明的优先**（last one wins）。顺序按样式表的顺序计算——`@import` 的样式视为在导入位置展开，后续规则覆盖前面的规则。' },
      { type: 'code', code: '/* 特异性相同，后声明优先 */\np { color: red; }\np { color: blue; }  /* 胜出，因为在后面 */\n\n/* 结果：color: blue */', lang: 'css', caption: '出现顺序是最后的裁判' },
      { type: 'tip', text: '利用出现顺序可以实现「渐进增强」——先写降级方案，再写新特性。旧浏览器跳过新语法，使用降级方案；新浏览器应用新特性覆盖降级方案。' },
      { type: 'list', items: [
        '层叠是多级排序算法：来源 → 上下文 → 附属样式 → 层级 → 特异性 → 顺序',
        '来源优先级：Transition > !important UA > !important User > !important Author > Animation > Author > User > UA',
        '`!important` 反转优先级顺序——用户的重要声明可以覆盖作者的',
        '层叠层（`@layer`）让你显式控制优先级，避免特异性竞赛',
        '特异性用三元组 `(ID, Class, Type)` 比较，不是十进制',
        '出现顺序是最后的裁判——后声明的覆盖先声明的'
      ] },
    ] as TutorialBlock[],
  },
  {
    id: 'defaulting',
    number: '7',
    title: { zh: '默认值', en: 'Defaulting' },
    summary: { zh: '当层叠没有结果时,通过继承或初始值确定属性值。可以使用 initial、inherit、unset、revert 关键字。', en: 'When cascading yields no result, property values are determined through inheritance or initial values. Keywords initial, inherit, unset, and revert can be used.' },
    keyPoints: [
      'initial: 将属性的指定值设为其初始值(initial value),无论该属性是否可继承',
      'inherit: 强制继承父元素的计算值;根元素无父元素时使用初始值',
      'unset: 继承属性等效 inherit,非继承属性等效 initial;可擦除层叠中此前的所有声明',
      'revert: 回滚到上一个来源的值;在作者来源中使用时回滚到用户来源,在用户来源中回滚到 UA 来源',
      'revert-layer(CSS Cascade 5 新增): 回滚到当前层叠层之下的层,若无更低层则回滚到上一个来源',
      '每个属性有初始值(initial value),在属性定义表中指定;非继承属性在层叠无结果时使用初始值',
      '继承属性(inherited property)在层叠无结果时使用父元素的计算值;属性定义表标明是否可继承',
      '继承沿文档树进行,不被匿名盒(anonymous box)截断;Shadow DOM 中 slot 分配的元素从 slot 继承而非 light tree 父元素',
      '伪元素按其定义的虚拟标签序列(fictional tag sequence)进行继承',
      'CSS 全局关键字(initial/inherit/unset/revert/revert-layer)可用于任何 CSS 属性,不能与其他值组合使用',
    ],
    tutorial: [
      { type: 'heading', text: '默认处理：层叠的降级机制' },
      { type: 'paragraph', text: '当某个属性没有层叠值（没有任何声明适用）时，CSS 通过**默认处理**（defaulting）确定属性值。默认处理有两个机制：**继承**（inheritance）和**初始值**（initial value）。每个属性在定义时就明确了是否可继承——可继承属性默认从父元素继承，非继承属性默认使用初始值。' },
      { type: 'code', code: '/* 默认处理的决策树 */\n某元素的某属性有层叠值吗？\n├─ 是 → 指定值 = 层叠值\n└─ 否 → 该属性可继承吗？\n    ├─ 是 → 指定值 = 父元素的计算值（继承）\n    └─ 否 → 指定值 = 初始值', lang: 'text', caption: '默认处理的决策逻辑' },
      { type: 'heading', text: '继承：属性值的自然传播' },
      { type: 'paragraph', text: '**继承**（inheritance）让子元素自动获得父元素的属性值。通常与**文本相关的属性**可继承（`color`、`font-family`、`line-height`、`text-align` 等），而**盒子模型属性**不可继承（`margin`、`padding`、`border`、`width` 等）。继承的设计目标是减少重复——在容器上设置字体，所有子元素自动应用。' },
      { type: 'example', title: '继承属性自动传播', code: '<div style="color: navy; font-size: 18px;">\n  <p>这段文字是深蓝色、18px</p>  <!-- 继承了 color 和 font-size -->\n  <span>这段也是</span>\n</div>', lang: 'html', explanation: '`<p>` 和 `<span>` 没有声明 `color` 和 `font-size`，通过继承获得父元素的值。' },
      { type: 'tip', text: '常见的可继承属性：`color`、`font-*`、`line-height`、`text-*`、`letter-spacing`、`word-spacing`、`white-space`、`list-style-*`、`cursor`、`visibility`。' },
      { type: 'code', code: '/* 非继承属性示例 */\n<div style="margin: 20px; border: 1px solid black;">\n  <p>我没有 margin 和 border</p>  <!-- 不继承盒子模型属性 -->\n</div>\n\n/* 结果：<p> 的 margin 是初始值 0，border 是初始值 none */', lang: 'html', caption: '非继承属性不会自动传播' },
      { type: 'heading', text: '初始值：属性的出厂设置' },
      { type: 'paragraph', text: '每个属性都有**初始值**（initial value），在属性定义表中指定。初始值是属性的「出厂设置」——如果没有声明、没有继承，属性就使用初始值。初始值通常是该属性最「无害」的值——`margin: 0`、`border: none`、`display: inline`（对大多数元素）。' },
      { type: 'code', code: '/* 常见属性的初始值 */\ncolor: canvastext;        /* 取决于系统（通常是黑色）*/\nbackground-color: transparent;\nmargin: 0;\npadding: 0;\nborder: none;  /* 等价于 medium none currentColor */\ndisplay: inline;          /* 大多数元素（块级元素除外）*/\nwidth: auto;\nheight: auto;', lang: 'css', caption: '初始值示例' },
      { type: 'heading', text: 'CSS 全局关键字' },
      { type: 'paragraph', text: 'CSS 定义了五个**全局关键字**（CSS-wide keywords），所有属性都接受。这些关键字让你显式控制默认处理机制——强制继承、强制初始值、回滚来源、回滚层级。' },
      { type: 'heading', text: 'initial：强制使用初始值' },
      { type: 'paragraph', text: '`initial` 关键字将属性的指定值设为其初始值，**无论该属性是否可继承**。`initial` 可以用来「擦除」继承——让继承属性使用初始值而非父元素的值。' },
      { type: 'example', title: '阻断继承', code: '<div style="color: red;">\n  <p style="color: initial;">这段文字不是红色</p>  <!-- color: canvastext (黑色) -->\n</div>', lang: 'html', explanation: '`color: initial` 强制使用初始值，阻断了从父元素继承红色。' },
      { type: 'heading', text: 'inherit：强制继承' },
      { type: 'paragraph', text: '`inherit` 关键字强制继承父元素的计算值，**无论该属性是否可继承**。`inherit` 可以让非继承属性也继承——例如让 `border` 从父元素继承（虽然通常不这么做）。' },
      { type: 'code', code: '/* 强制继承非继承属性 */\n.parent {\n  border: 2px solid blue;\n}\n\n.child {\n  border: inherit;  /* 继承父元素的 border: 2px solid blue */\n}', lang: 'css', caption: 'inherit 让非继承属性也继承' },
      { type: 'tip', text: '根元素（`<html>`）没有父元素——对根元素使用 `inherit` 等价于 `initial`。' },
      { type: 'heading', text: 'unset：智能擦除' },
      { type: 'paragraph', text: '`unset` 关键字是**智能版的擦除**——对继承属性等效于 `inherit`，对非继承属性等效于 `initial`。`unset` 可以用来「撤销」层叠中此前的所有声明，回到默认状态。' },
      { type: 'code', code: '/* unset 的智能行为 */\ncolor: unset;      /* 继承属性 → 等价于 inherit */\nmargin: unset;     /* 非继承属性 → 等价于 initial (0) */\n\n/* 批量撤销 */\n.reset {\n  all: unset;      /* 所有属性回到默认状态 */\n}', lang: 'css', caption: 'unset 是最常用的「恢复默认」方式' },
      { type: 'heading', text: 'revert：回滚到上一个来源' },
      { type: 'paragraph', text: '`revert` 关键字回滚到**上一个来源**的值——在作者样式表中使用时回滚到用户来源，在用户来源中回滚到 UA 来源（浏览器默认样式）。`revert` 让你可以「撤销」作者样式，回到浏览器的默认外观。' },
      { type: 'example', title: '回滚到浏览器默认样式', code: '/* 作者样式表 */\nbutton {\n  all: revert;  /* 忽略作者样式，回到 UA 样式（浏览器默认按钮外观）*/\n}', lang: 'css', explanation: '`revert` 让按钮显示为浏览器的原生样式，而不是自定义样式。' },
      { type: 'code', code: '/* revert 在不同来源中的行为 */\n作者样式表中: revert → 回滚到用户来源（若有）→ UA 来源\n用户样式表中: revert → 回滚到 UA 来源\nUA 样式表中: revert → 等价于 unset', lang: 'text', caption: 'revert 沿来源链回滚' },
      { type: 'heading', text: 'revert-layer：回滚到上一个层' },
      { type: 'paragraph', text: '`revert-layer`（CSS Cascade 5 新增）回滚到**当前层叠层之下的层**。如果没有更低优先级的层，则回滚到上一个来源。`revert-layer` 让你可以在层叠层中「透传」值，而不完全覆盖。' },
      { type: 'code', code: '@layer base, theme, overrides;\n\n@layer base {\n  button { background: gray; }\n}\n\n@layer theme {\n  button { background: blue; }\n}\n\n@layer overrides {\n  .special-button {\n    background: revert-layer;  /* 回滚到 theme 层的 blue */\n  }\n}', lang: 'css', caption: 'revert-layer 在层叠层间跳转' },
      { type: 'heading', text: '继承沿文档树传播' },
      { type: 'paragraph', text: '继承沿**文档树**（document tree）传播，不被**匿名盒**（anonymous box）截断。在 Shadow DOM 中，通过 `<slot>` 分配的元素从 `slot` 继承，而不是从 light tree 的父元素继承——这确保了样式的封装性。' },
      { type: 'code', code: '/* Shadow DOM 中的继承 */\n<my-component>\n  <span>内容</span>  <!-- 从 slot 继承，而非 <my-component> -->\n</my-component>\n\n/* Shadow root */\n<slot style="color: red;"></slot>\n\n/* 结果：<span> 的 color 是 red（从 slot 继承）*/', lang: 'html', caption: 'Shadow DOM 改变了继承链' },
      { type: 'tip', text: '伪元素（如 `::before`、`::after`）从生成它们的元素继承，就像它们是该元素的真实子元素一样。' },
      { type: 'warning', text: 'CSS 全局关键字**不能与其他值组合**——`color: red inherit` 是无效的。全局关键字必须单独使用。' },
      { type: 'list', items: [
        '默认处理通过继承或初始值确定没有层叠值的属性',
        '可继承属性从父元素继承计算值，非继承属性使用初始值',
        '`initial`：强制使用初始值（阻断继承）',
        '`inherit`：强制继承（让非继承属性也继承）',
        '`unset`：智能擦除（继承属性继承，非继承属性初始化）',
        '`revert`：回滚到上一个来源（撤销作者样式）',
        '`revert-layer`：回滚到上一个层叠层',
        '继承沿文档树传播，传递的是父元素的计算值'
      ] },
    ] as TutorialBlock[],
  },
];

export const anchors: Record<string, string> = {
  'cascade': 'cascading',
  'specificity': 'cascading',
  'important-rules': 'cascading',
  'inheritance': 'defaulting',
  'initial-value': 'value-stages',
  'specified-value': 'value-stages',
  'computed-value': 'value-stages',
  'computed-values': 'value-stages',
  'actual-value': 'value-stages',
  'usedValue': 'value-stages',
  'used-value': 'value-stages',
  'at-import': 'at-import',
};

export const glossaryTerms: Record<string, GlossaryEntry> = {
  'cascading': {
    zh: '层叠',
    description: '当多条规则试图设置同一元素的同一属性时,层叠机制按来源、重要性、特异性和顺序决定最终值。',
    sectionRef: 'cascade#cascading',
    css2Url: 'https://www.w3.org/TR/CSS22/cascade.html#cascade',
    specUrl: 'https://www.w3.org/TR/css-cascade-4/#cascading',
  },
  'specificity': {
    zh: '特异性(优先级)',
    description: '选择器的权重三元组 (ID, Class, Type),用于在层叠中比较同一来源、同一重要性的声明的优先级。',
    sectionRef: 'cascade#cascading',
    css2Url: 'https://www.w3.org/TR/CSS22/cascade.html#specificity',
    specUrl: 'https://www.w3.org/TR/selectors-4/#specificity',
  },
  'inheritance': {
    zh: '继承',
    description: '某些 CSS 属性(如 color、font-size)会自动从父元素传递到子元素,无需显式声明。',
    sectionRef: 'cascade#defaulting',
    css2Url: 'https://www.w3.org/TR/CSS22/cascade.html#inheritance',
    specUrl: 'https://www.w3.org/TR/css-cascade-4/#inheriting',
  },
  'specified value': {
    zh: '指定值',
    description: '经过层叠和默认处理后确定的属性值。如果层叠有结果就用层叠值,否则用继承值或初始值。',
    sectionRef: 'cascade#value-stages',
  },
  'computed value': {
    zh: '计算值',
    description: '将指定值中的相对值(如 em、百分比)转换为绝对值的结果。计算值是继承时传递给子元素的值。',
    sectionRef: 'cascade#value-stages',
  },
  'used value': {
    zh: '使用值',
    description: '将计算值应用到布局后的最终值。例如 width: 50% 在包含块宽度 800px 时,使用值为 400px。',
    sectionRef: 'cascade#value-stages',
  },
  'shorthand property': {
    zh: '简写属性',
    description: '同时设置多个相关属性的简写形式,如 margin、background、border。注意简写会重置所有子属性。',
    sectionRef: 'cascade#shorthand',
  },
  'declared value': {
    zh: '声明值',
    description: '对某元素的某个属性,所有匹配该元素的声明中给出的值的集合。是层叠处理的输入。',
    sectionRef: 'cascade#value-stages',
    css2Url: 'https://www.w3.org/TR/CSS22/cascade.html#value-def-declared',
  },
  'cascaded value': {
    zh: '层叠值',
    description: '经过层叠排序后胜出的那个声明值。如果没有声明,则该属性没有层叠值。',
    sectionRef: 'cascade#value-stages',
    css2Url: 'https://www.w3.org/TR/CSS22/cascade.html#value-def-cascaded',
  },
  'actual value': {
    zh: '实际值',
    description: '使用值经过最终环境限制(如屏幕分辨率、可用字体)调整后的值。浏览器实际用于渲染的最终值。',
    sectionRef: 'cascade#value-stages',
    css2Url: 'https://www.w3.org/TR/CSS22/cascade.html#actual-value',
  },
  'cascade origin': {
    zh: '层叠来源',
    description: '声明的来源分类:User-Agent(浏览器默认)、User(用户样式)、Author(开发者样式)。不同来源有不同的优先级。',
    sectionRef: 'cascade#cascading',
    specUrl: 'https://www.w3.org/TR/css-cascade-4/#origin',
  },
  'author origin': {
    zh: '作者来源',
    description: '开发者编写的样式表的层叠来源,包括 <style> 标签、外部 CSS 文件和行内样式。',
    sectionRef: 'cascade#cascading',
  },
  'user origin': {
    zh: '用户来源',
    description: '用户通过浏览器设置自定义的样式表的层叠来源。优先级低于作者来源(非 !important 时)。',
    sectionRef: 'cascade#cascading',
  },
  'user-agent origin': {
    zh: '用户代理来源',
    description: '浏览器内置的默认样式表的层叠来源。优先级最低(非 !important 时),定义了元素的默认外观。',
    sectionRef: 'cascade#cascading',
  },
  'important': {
    zh: '重要声明',
    description: '用 !important 标记的声明。重要声明的层叠优先级顺序与普通声明相反:UA > User > Author。',
    sectionRef: 'cascade#cascading',
    css2Url: 'https://www.w3.org/TR/CSS22/cascade.html#important-rules',
  },
  'shorthand properties': {
    zh: '简写属性',
    description: '一次性设置多个相关子属性的属性,如 margin、background、font。简写会重置所有子属性,包括未显式指定的。',
    sectionRef: 'cascade#shorthand',
    css2Url: 'https://www.w3.org/TR/CSS22/about.html#shorthand',
  },
  'longhand sub-properties': {
    zh: '子属性',
    description: '简写属性展开后对应的各个独立属性。如 border 的子属性包括 border-width、border-style、border-color。',
    sectionRef: 'cascade#shorthand',
  },
  'cascade layer': {
    zh: '层叠层',
    description: 'CSS Cascade 5 引入的机制,允许作者在同一来源内将样式规则组织到不同层中,按层的声明顺序控制优先级,而无需依赖选择器特异性或源码顺序。',
    sectionRef: 'cascade#cascading',
    specUrl: 'https://www.w3.org/TR/css-cascade-5/#layering',
  },
  '@layer': {
    zh: '@layer 规则',
    description: '用于声明层叠层的 at 规则。支持块语法(包含样式规则)和语句语法(仅声明层名和顺序)。层名可嵌套,用点号分隔表示层级。',
    sectionRef: 'cascade#cascading',
    specUrl: 'https://www.w3.org/TR/css-cascade-5/#at-layer',
  },
  'revert-layer': {
    zh: 'revert-layer 关键字',
    description: 'CSS Cascade 5 新增的全局关键字,将属性值回滚到当前层叠层之下的层。若无更低优先级的层,则回滚到上一个来源。',
    sectionRef: 'cascade#defaulting',
    specUrl: 'https://www.w3.org/TR/css-cascade-5/#revert-layer',
  },
  'encapsulation context': {
    zh: '封装上下文',
    description: '文档语言提供的声明来源隔离机制,如 Shadow DOM 的树上下文(tree context)。层叠中普通规则外层上下文优先,!important 规则内层上下文优先。',
    sectionRef: 'cascade#cascading',
    specUrl: 'https://www.w3.org/TR/css-cascade-5/#cascade-context',
  },
  'shadow dom': {
    zh: 'Shadow DOM',
    description: 'Web Components 的封装机制,创建独立的 DOM 子树和样式作用域。在层叠中形成独立的封装上下文,继承沿扁平树(flat tree)而非 light tree 进行。',
    sectionRef: 'cascade#cascading',
  },
  'presentational hints': {
    zh: '表现性提示',
    description: '文档标记中的表现性属性(如 HTML 的 bgcolor、<s> 元素),被转换为等效 CSS 规则进入层叠。进入 UA 来源或特殊的作者表现性提示来源(位于用户来源与作者来源之间)。',
    sectionRef: 'cascade#cascading',
    css2Url: 'https://www.w3.org/TR/CSS22/cascade.html#preshint',
    specUrl: 'https://www.w3.org/TR/css-cascade-5/#preshint',
  },
  'initial value': {
    zh: '初始值',
    description: '每个属性在定义表中指定的默认值。非继承属性在层叠无结果时使用初始值作为指定值。',
    sectionRef: 'cascade#defaulting',
    css2Url: 'https://www.w3.org/TR/CSS22/cascade.html#specified-value',
    specUrl: 'https://www.w3.org/TR/css-cascade-5/#initial-values',
  },
  'inherited property': {
    zh: '继承属性',
    description: '属性定义表中标记为"inherited: yes"的属性。当层叠无结果时,自动使用父元素的计算值。典型例子:color、font-size、line-height。',
    sectionRef: 'cascade#defaulting',
    specUrl: 'https://www.w3.org/TR/css-cascade-5/#inheriting',
  },
  'css-wide keywords': {
    zh: 'CSS 全局关键字',
    description: '所有 CSS 属性都接受的关键字:initial(初始值)、inherit(继承)、unset(擦除)、revert(回滚来源)、revert-layer(回滚层)。不能与其他值组合。',
    sectionRef: 'cascade#defaulting',
    specUrl: 'https://www.w3.org/TR/css-values-4/#css-wide-keywords',
  },
  'reset-only sub-property': {
    zh: '仅重置子属性',
    description: '简写属性的一种特殊子属性:被简写重置为初始值,但简写语法无法将其设为其他值。如 border 会重置 border-image 为 none。',
    sectionRef: 'cascade#shorthand',
    specUrl: 'https://www.w3.org/TR/css-cascade-5/#shorthand',
  },
};

export const propertyTerms: Record<string, PropertyEntry> = {
  'all': {
    zh: '全部属性简写',
    value: 'initial | inherit | unset | revert | revert-layer',
    initial: '见各属性定义',
    appliesTo: '见各属性定义',
    inherited: false,
    percentages: null,
    computedValue: '见各属性定义',
    css2Url: 'https://www.w3.org/TR/css-cascade-4/#all-shorthand',
    css3Url: 'https://www.w3.org/TR/css-cascade-5/#all-shorthand',
    sectionRef: 'cascade#shorthand',
  },
};

import type { Section, TutorialBlock } from '../modules';
import type { GlossaryEntry } from '../glossary';
import type { PropertyEntry } from '../properties';

export const sections: Section[] = [
  {
    id: 'intro',
    number: '1',
    title: { zh: '简介', en: 'Introduction' },
    specId: 'intro',
    summary: {
      zh: 'CSS 将元素树转换为一组盒子,每个盒子有矩形的内容区域,以及可选的 padding、border 和 margin 区域。',
      en: 'CSS transforms the element tree into a set of boxes, each with a rectangular content area and optional padding, border, and margin areas.',
    },
    keyPoints: [
      '元素树(element tree)被转换为盒子树(box tree)',
      '每个盒子有 content、padding、border、margin 四个区域',
      'sizing 属性决定内容区域大小,box styling 属性决定其他区域大小',
      '本模块仅定义物理方向(top/right/bottom/left)的属性,逻辑方向属性在 css-logical-1 中定义',
      '物理方向和逻辑方向的 longhand 属性控制的是同一组 margin/padding,只是索引方式不同',
      '本模块替换了 CSS2 第 8.1、8.2、8.3(不含 8.3.1)、8.4 节的定义',
      '所有属性均适用于 ::first-line 和 ::first-letter 伪元素',
      '盒子的大小、位置和层叠层级取决于其 CSS 属性的值',
      'CSS Cascading and Inheritance 负责将属性分配给元素,CSS Display 负责将元素树转换为盒子树',
    ],
    tutorial: [
      { type: 'heading', text: '盒模型：CSS 布局的基石' },
      { type: 'paragraph', text: 'CSS 盒模型是理解 CSS 布局的第一步。每个 HTML 元素在渲染时都会生成一个或多个矩形的**盒子**（box）。这些盒子是 CSS 布局的基本单元——浏览器通过计算盒子的尺寸、位置和层叠关系来完成页面渲染。盒模型定义了盒子的内部结构：从内到外依次是 content（内容）、padding（内边距）、border（边框）、margin（外边距）四个区域。理解这四个区域如何协同工作，是掌握 CSS 布局的关键。' },
      { type: 'code', code: '/* 盒子的四个区域 */\n.box {\n  /* content 区域由 width/height 控制 */\n  width: 200px;\n  height: 100px;\n  \n  /* padding 在 content 外围提供内边距 */\n  padding: 20px;\n  \n  /* border 在 padding 外围绘制边框 */\n  border: 5px solid navy;\n  \n  /* margin 在 border 外围提供外边距 */\n  margin: 30px;\n}', lang: 'css', caption: '盒子的四个区域及其控制属性' },
      { type: 'heading', text: '从元素树到盒子树' },
      { type: 'paragraph', text: 'HTML 源文档被解析为**元素树**（element tree）——一个元素的层次结构。CSS 的任务是将元素树转换为**盒子树**（box tree）用于渲染。关键点：元素和盒子不是一对一关系。一个元素可能生成零个盒子（`display: none`）、一个盒子（大多数情况）、或多个盒子（如 `display: list-item` 生成主盒子和标记盒子）。' },
      { type: 'example', title: '元素生成多个盒子', code: '<li>列表项内容</li>', lang: 'html', explanation: '`<li>` 元素生成两个盒子：主盒子（包含文本）和标记盒子（项目符号 •）。两个盒子都遵循盒模型，都有自己的 padding、border、margin。' },
      { type: 'heading', text: '盒子的尺寸计算' },
      { type: 'paragraph', text: '盒子的总尺寸取决于多个属性的组合。**sizing 属性**（如 `width`、`height`）决定内容区域的大小，**box styling 属性**（`padding`、`border`、`margin`）决定其他区域的大小。最终盒子占据的空间是所有区域的总和（或者说，margin edge 包围的区域）。' },
      { type: 'code', code: '/* 盒子总宽度计算 */\n.box {\n  width: 200px;        /* content-box 宽度 */\n  padding: 20px;       /* 左右各 20px = 40px */\n  border: 5px solid;   /* 左右各 5px = 10px */\n  margin: 30px;        /* 左右各 30px = 60px */\n}\n/* 总宽度 = 200 + 40 + 10 + 60 = 310px\n   总宽度指 margin edge 包围的宽度 */', lang: 'css', caption: '默认情况下 width 只包含 content' },
      { type: 'tip', text: '`box-sizing: border-box` 可以改变 `width` 的含义——让 `width` 包含 padding 和 border，使尺寸计算更直观。这是现代 CSS 的常见做法。' },
      { type: 'heading', text: '物理方向与逻辑方向' },
      { type: 'paragraph', text: 'CSS Box Model 定义了**物理方向**的属性（`margin-top`、`padding-right` 等），它们直接对应屏幕的上下左右。CSS Logical Properties 模块定义了**逻辑方向**的属性（`margin-block-start`、`padding-inline-end` 等），它们相对于文本流方向。物理属性和逻辑属性控制的是**同一组底层 margin/padding/border**，只是索引方式不同——在水平 LTR 书写模式下，`margin-top` 等同于 `margin-block-start`。' },
      { type: 'code', code: '/* 物理属性 */\n.box {\n  margin-top: 20px;    /* 固定指向屏幕上方 */\n  margin-left: 10px;   /* 固定指向屏幕左侧 */\n}\n\n/* 逻辑属性（相同效果，在水平 LTR 模式下）*/\n.box {\n  margin-block-start: 20px;   /* 块方向起始侧 = 上方 */\n  margin-inline-start: 10px;  /* 行内方向起始侧 = 左侧 */\n}', lang: 'css', caption: '物理属性 vs 逻辑属性' },
      { type: 'warning', text: '物理属性和逻辑属性同时设置时，遵循正常的层叠规则——后声明的覆盖先声明的。它们不是独立的属性系统，而是同一组属性的不同访问方式。' },
      { type: 'heading', text: '盒子的属性继承与层叠' },
      { type: 'paragraph', text: 'CSS Cascading and Inheritance 模块负责为每个元素的每个属性确定最终值，CSS Display 模块负责将元素转换为盒子。盒子的大小、位置、层叠层级完全取决于 CSS 属性的计算值。盒模型属性（`margin`、`padding`、`border`）**不会继承**——子元素不会自动获得父元素的 margin 或 padding 值。每个盒子的这些属性都是独立计算的。' },
      { type: 'list', items: [
        'CSS 将元素树转换为盒子树，元素与盒子不是一对一关系',
        '每个盒子有四个区域：content、padding、border、margin',
        'sizing 属性控制 content 尺寸，box styling 属性控制其他区域',
        '物理属性和逻辑属性控制同一组底层属性，只是索引方式不同',
        '盒模型属性不会继承——每个盒子独立计算'
      ] },
      { type: 'tip', text: '盒模型是 CSS 的核心抽象——后续所有布局系统（Flexbox、Grid、定位）都建立在盒模型之上。花时间理解盒模型的每个细节是值得的。' },
    ] as TutorialBlock[],
  },
  {
    id: 'box-model',
    number: '2',
    title: { zh: '盒模型', en: 'The CSS Box Model' },
    specId: 'box-model',
    summary: {
      zh: '每个盒子有 content area 及可选的 padding、border、margin 区域。各区域大小由对应属性控制,margin 可以为负值。',
      en: 'Each box has a content area and optional padding, border, and margin areas. Each area size is controlled by corresponding properties; margin can be negative.',
    },
    keyPoints: [
      'content、padding、border 的背景由 background 属性控制',
      'margin 始终是透明的',
      '四种边缘:content edge(内边缘)、padding edge、border edge、margin edge(外边缘)',
      '四种盒子:content-box、padding-box、border-box、margin-box',
      'box-edge 关键字可用于 transform-box、background-clip 等属性',
      '当某侧 padding/border/margin 为 0 时,对应 edge 与内层 edge 重合',
      'margin、border、padding 各可分为 top、right、bottom、left 四段独立控制',
      '盒子分片(fragmentation)时,content/padding/border/margin 区域也随之分片,由 box-decoration-break 属性控制',
      'border-radius 可改变 edge 形状用于绘制和裁剪,但通常不影响布局;规范区分 shaped edge 和 unshaped edge',
      '<box> 类型定义了 <visual-box>(content/padding/border)、<layout-box>(+margin)、<paint-box>(+fill/stroke)、<coord-box>(+view) 等子集',
    ],
    tutorial: [
      { type: 'heading', text: '盒子的四个区域' },
      { type: 'paragraph', text: '每个 CSS 盒子从内到外由四个同心矩形区域组成。最内层是 **content area**（内容区域），包含元素的实际内容（文本、图片、子元素等）。content area 外围是 **padding area**（内边距区域），提供内容与边框之间的空间。padding 外围是 **border area**（边框区域），可以绘制边框线。最外层是 **margin area**（外边距区域），提供盒子与其他盒子之间的间距。' },
      { type: 'code', code: '/* 四个区域的可视化 */\n.box {\n  width: 200px;              /* content area 宽度 */\n  height: 100px;             /* content area 高度 */\n  padding: 20px;             /* padding area 四周各 20px */\n  border: 5px solid blue;    /* border area 四周各 5px，蓝色实线 */\n  margin: 30px;              /* margin area 四周各 30px */\n  background: lightblue;     /* 背景延伸到 padding edge */\n}', lang: 'css', caption: '四个区域的定义' },
      { type: 'heading', text: '四种边缘（edge）' },
      { type: 'paragraph', text: '每个区域的外边界称为 **edge**（边缘）。从内到外依次是：**content edge**（内容边缘，也叫 inner edge 内边缘）、**padding edge**（内边距边缘）、**border edge**（边框边缘）、**margin edge**（外边距边缘，也叫 outer edge 外边缘）。这些边缘围成的矩形区域就是对应的 box（如 padding edge 围成 padding-box）。' },
      { type: 'tip', text: '当某一侧的 padding/border/margin 为 0 时，对应的 edge 会与内层 edge 重合。例如 `padding: 0` 时，padding edge 与 content edge 重合。' },
      { type: 'heading', text: '四种盒子（box）' },
      { type: 'list', items: [
        '**content-box**：由 content edge 围成，只包含内容区域',
        '**padding-box**：由 padding edge 围成，包含内容 + 内边距',
        '**border-box**：由 border edge 围成，包含内容 + 内边距 + 边框',
        '**margin-box**：由 margin edge 围成，包含所有四个区域'
      ] },
      { type: 'paragraph', text: '这些 box 关键字在多个 CSS 属性中使用。例如 `box-sizing: border-box` 让 `width` 和 `height` 相对于 border-box 计算，`background-clip: content-box` 让背景只绘制到 content edge。' },
      { type: 'code', code: '/* box-sizing 影响尺寸计算 */\n.content-box-sizing {\n  box-sizing: content-box;  /* 默认值 */\n  width: 200px;             /* width 只包含 content */\n  padding: 20px;\n  border: 5px solid;\n  /* 实际渲染宽度 = 200 + 40 + 10 = 250px */\n}\n\n.border-box-sizing {\n  box-sizing: border-box;\n  width: 200px;             /* width 包含 content + padding + border */\n  padding: 20px;\n  border: 5px solid;\n  /* 实际渲染宽度 = 200px（content 被压缩到 150px）*/\n}', lang: 'css', caption: 'box-sizing 改变 width 的含义' },
      { type: 'heading', text: '背景与透明度' },
      { type: 'paragraph', text: 'CSS 的 `background` 属性控制 content、padding、border 三个区域的背景。默认情况下，背景延伸到 **border edge**（即绘制在 border 区域下方，如果 border 是透明或半透明的，背景会透过显示）。**margin 始终是透明的**——margin area 永远不会绘制背景，它是完全透明的空间。' },
      { type: 'example', title: '背景延伸到 border 下方', code: '.box {\n  background: yellow;\n  border: 10px dashed rgba(0,0,0,0.3);  /* 半透明虚线边框 */\n}', lang: 'css', explanation: '黄色背景会延伸到 border area，通过半透明的虚线边框可以看到背景色。' },
      { type: 'code', code: '/* 通过 background-clip 控制背景绘制区域 */\n.clip-to-padding {\n  background: yellow;\n  background-clip: padding-box;  /* 背景只绘制到 padding edge */\n  border: 10px solid transparent;\n  /* border 区域是透明的，不显示背景 */\n}\n\n.clip-to-content {\n  background: yellow;\n  background-clip: content-box;  /* 背景只绘制到 content edge */\n  padding: 20px;\n  /* padding 区域也不显示背景 */\n}', lang: 'css', caption: 'background-clip 控制背景裁剪' },
      { type: 'heading', text: '独立控制四个方向' },
      { type: 'paragraph', text: 'margin、padding、border 都可以分别为 top、right、bottom、left 四个方向设置不同的值。CSS 提供了 longhand 属性（如 `margin-top`）和 shorthand 属性（如 `margin`）两种方式。' },
      { type: 'code', code: '/* longhand: 每个方向独立声明 */\n.box {\n  margin-top: 10px;\n  margin-right: 20px;\n  margin-bottom: 10px;\n  margin-left: 20px;\n}\n\n/* shorthand: 一次性声明 1-4 个值 */\n.box {\n  margin: 10px 20px;        /* 上下 10px，左右 20px */\n  margin: 10px 20px 30px;   /* 上 10px，左右 20px，下 30px */\n  margin: 10px 20px 30px 5px; /* 上右下左（顺时针）*/\n}', lang: 'css', caption: 'longhand vs shorthand' },
      { type: 'heading', text: 'margin 可以为负值' },
      { type: 'paragraph', text: '与 padding 和 border 不同，**margin 可以为负值**。负 margin 会让盒子向相反方向移动，甚至可以让盒子重叠。这是 CSS 布局中的强大工具，但也容易造成意外效果。' },
      { type: 'example', title: '负 margin 的效果', code: '.overlap {\n  margin-left: -20px;  /* 盒子向左移动 20px，可能与左侧元素重叠 */\n  margin-top: -10px;   /* 盒子向上移动 10px */\n}', lang: 'css', explanation: '负 margin 改变盒子的位置，但不影响盒子本身的尺寸。' },
      { type: 'warning', text: 'padding 和 border 的宽度**不允许负值**。如果你设置了负值（如 `padding: -10px`），浏览器会忽略这条声明。' },
      { type: 'heading', text: '盒子分片与 box-decoration-break' },
      { type: 'paragraph', text: '当盒子跨行、跨列或跨页断裂时（称为 **fragmentation**，分片），content/padding/border/margin 区域也会随之分片。`box-decoration-break` 属性控制分片时装饰（padding、border、background）如何处理：`slice`（默认值，切片延续）或 `clone`（每个片段独立装饰）。' },
      { type: 'code', code: '/* 行内元素跨行时的装饰处理 */\n.inline-box {\n  background: yellow;\n  padding: 5px 10px;\n  border: 2px solid blue;\n  box-decoration-break: clone;  /* 每行独立装饰 */\n}\n/* 如果文本跨两行，每行的起始和结束都会有完整的 padding 和 border */', lang: 'css', caption: 'box-decoration-break 控制分片装饰' },
      { type: 'heading', text: 'border-radius 与 shaped edge' },
      { type: 'paragraph', text: '`border-radius` 可以改变盒子的边缘形状，将矩形变为圆角矩形。规范区分 **shaped edge**（有圆角的边缘）和 **unshaped edge**（直角边缘）。圆角边缘用于绘制和裁剪（如 `background-clip`、`overflow`），但**通常不影响布局**——浮动元素不会绕着圆角流动，inline 内容也不会。' },
      { type: 'tip', text: 'border-radius 主要影响视觉呈现，不影响布局计算。布局算法仍然使用未圆角化的矩形 box。' },
      { type: 'list', items: [
        '盒子有四个同心区域：content、padding、border、margin',
        '四种边缘围成四种 box：content-box、padding-box、border-box、margin-box',
        '背景延伸到 border edge，margin 始终透明',
        'margin 可以为负值，padding 和 border 不行',
        '每个区域可以为四个方向独立设置不同值',
        'box-decoration-break 控制分片时装饰的处理方式',
        'border-radius 改变视觉形状，通常不影响布局'
      ] },
    ] as TutorialBlock[],
  },
  {
    id: 'margins',
    number: '3',
    title: { zh: '外边距', en: 'Margins' },
    specId: 'margins',
    summary: {
      zh: 'Margin 在 border edge 外围提供盒子之间的间距。支持 margin-top/right/bottom/left 和 margin 简写。',
      en: 'Margin provides spacing between boxes outside the border edge. Supports margin-top/right/bottom/left and margin shorthand.',
    },
    keyPoints: [
      'margin 初始值为 0,不可继承',
      '允许负值(但可能有实现限制)',
      '百分比相对于包含块的逻辑宽度(包括 margin-top/margin-bottom)',
      '不适用于 internal table elements、ruby base containers 和 ruby annotation containers',
      'block layout 中相邻的 margin 会发生折叠(collapsing):结果取较大值,负值则从正值中扣除绝对值',
      '简写 margin 的 1-4 个值分别对应不同方向:1值=全部,2值=上下/左右,3值=上/左右/下,4值=上/右/下/左',
      'margin 值可以是 auto,用于水平居中或由布局算法计算',
      '垂直方向的 margin 对非替换行内元素无效',
      'margin-trim(CSS Box 4)允许容器裁剪子元素靠近容器边缘的 margin,适用于 block/flex/grid 容器',
      '分片断裂处(fragmentation break)相邻的 margin 可能被截断,由 margin-break 属性控制',
    ],
    tutorial: [
      { type: 'heading', text: 'margin 的作用：盒子间的间距' },
      { type: 'paragraph', text: '**margin**（外边距）在盒子的 border edge 外围创建透明空间，用于控制盒子与其他盒子之间的距离。与 padding 不同，margin 不属于盒子的视觉部分——它不会显示背景，完全透明。margin 的主要用途是布局间距：段落之间的垂直间距、卡片之间的水平间距、内容与容器边缘的距离。' },
      { type: 'code', code: '/* margin 的四个方向 */\n.box {\n  margin-top: 20px;      /* 上方留出 20px 空间 */\n  margin-right: 10px;    /* 右侧留出 10px 空间 */\n  margin-bottom: 20px;   /* 下方留出 20px 空间 */\n  margin-left: 10px;     /* 左侧留出 10px 空间 */\n}', lang: 'css', caption: 'margin 的 longhand 属性' },
      { type: 'heading', text: 'margin 简写：1-4 个值的语法' },
      { type: 'paragraph', text: '`margin` 简写属性可以接受 1 到 4 个值，按顺时针方向（上 → 右 → 下 → 左）应用。这种语法规则在 CSS 中非常常见（`padding`、`border-width` 等也遵循相同规则）。' },
      { type: 'code', code: '/* 1 个值：四个方向相同 */\nmargin: 20px;  /* 上右下左都是 20px */\n\n/* 2 个值：上下 | 左右 */\nmargin: 20px 10px;  /* 上下 20px，左右 10px */\n\n/* 3 个值：上 | 左右 | 下 */\nmargin: 20px 10px 30px;  /* 上 20px，左右 10px，下 30px */\n\n/* 4 个值：上 | 右 | 下 | 左（顺时针）*/\nmargin: 20px 10px 30px 5px;', lang: 'css', caption: 'margin 简写的值语法' },
      { type: 'tip', text: '记忆技巧：想象时钟从 12 点（上）开始顺时针旋转——上、右、下、左。2 个值时上下成对、左右成对；3 个值时左右共用中间值。' },
      { type: 'heading', text: 'margin 允许负值' },
      { type: 'paragraph', text: '与 padding 不同，**margin 可以为负值**。负 margin 会让盒子向相反方向移动，可以用于重叠布局、精确定位或抵消默认间距。负 margin 是 CSS 布局的强大工具，但需要谨慎使用。' },
      { type: 'example', title: '负 margin 的实际应用', code: '.card {\n  margin-top: -50px;  /* 向上移动 50px，与上方元素重叠 */\n}\n\n.full-bleed {\n  margin-left: -20px;\n  margin-right: -20px;\n  /* 突破容器的 padding 限制，延伸到容器边缘 */\n}', lang: 'css', explanation: '负 margin 改变盒子的位置，但不改变盒子本身的尺寸。' },
      { type: 'warning', text: '负 margin 可能导致内容重叠或超出父容器边界。使用前要明确理解布局上下文，避免意外效果。' },
      { type: 'heading', text: '百分比 margin 相对于包含块的宽度' },
      { type: 'paragraph', text: 'margin 可以使用百分比值，**包括 `margin-top` 和 `margin-bottom`**。重要细节：**所有方向的百分比都相对于包含块的宽度**（width），而非高度。这是 CSS 的设计选择，目的是避免循环依赖（如果垂直 margin 依赖高度，而高度又依赖子元素，会导致无限循环）。' },
      { type: 'code', code: '/* 百分比 margin 的计算 */\n.container {\n  width: 400px;\n  height: 600px;\n}\n\n.box {\n  margin-top: 10%;     /* 10% × 400px(容器宽度) = 40px */\n  margin-bottom: 10%;  /* 10% × 400px = 40px，不是 60px */\n  margin-left: 5%;     /* 5% × 400px = 20px */\n}', lang: 'css', caption: '垂直 margin 百分比也相对于宽度' },
      { type: 'tip', text: '这个特性可以用来创建固定宽高比的间距——用百分比 margin 实现响应式的垂直间距。' },
      { type: 'heading', text: 'margin: auto 与水平居中' },
      { type: 'paragraph', text: '`margin` 属性接受特殊关键字 `auto`，让浏览器自动计算 margin 值。在块级盒子中，左右 `auto` margin 会平分可用空间，实现**水平居中**。这是 CSS 中最常用的居中技巧之一。' },
      { type: 'example', title: '块级元素水平居中', code: '.centered-box {\n  width: 600px;           /* 必须有明确宽度 */\n  margin-left: auto;      /* 左侧自动填充 */\n  margin-right: auto;     /* 右侧自动填充 */\n  /* 或简写：margin: 0 auto; */\n}', lang: 'css', explanation: '浏览器计算左右可用空间并平分，实现居中。' },
      { type: 'warning', text: '垂直方向的 `margin: auto` 在块级布局中计算为 0（不会垂直居中）。垂直居中需要使用其他技术（Flexbox、Grid 或绝对定位）。' },
      { type: 'heading', text: '垂直 margin 对行内元素无效' },
      { type: 'paragraph', text: '**非替换行内元素**（如 `<span>`、`<a>`）的 `margin-top` 和 `margin-bottom` **不会影响布局**。行内元素只有水平 margin 生效，垂直 margin 被忽略。这是行内格式化上下文（IFC）的特殊规则。' },
      { type: 'code', code: '/* 行内元素的 margin */\n.inline-element {\n  display: inline;  /* 默认值 */\n  margin-top: 20px;     /* ✗ 无效，不影响布局 */\n  margin-bottom: 20px;  /* ✗ 无效，不影响布局 */\n  margin-left: 10px;    /* ✓ 有效 */\n  margin-right: 10px;   /* ✓ 有效 */\n}', lang: 'css', caption: '行内元素只有水平 margin 生效' },
      { type: 'tip', text: '如果需要给行内元素添加垂直间距，使用 `line-height` 或将元素改为 `display: inline-block`。' },
      { type: 'heading', text: 'margin 折叠（collapsing）' },
      { type: 'paragraph', text: '在块级布局（block layout）中，相邻的垂直 margin 会**折叠**（collapse）成单个 margin，而不是简单相加。折叠规则：两个正 margin 取较大值；一正一负时用正值减去负值的绝对值；两个负值取绝对值较大的负值。margin 折叠是 CSS 中最容易被误解的特性之一，第 6 节会详细讲解。' },
      { type: 'example', title: 'margin 折叠示例', code: '.box1 {\n  margin-bottom: 30px;  /* 下方 30px */\n}\n\n.box2 {\n  margin-top: 20px;     /* 上方 20px */\n}\n\n/* 两个盒子之间的实际间距是 30px（取较大值），不是 50px */', lang: 'css', explanation: '相邻的垂直 margin 折叠为一个，取两者中的较大值。' },
      { type: 'heading', text: 'margin-trim：容器裁剪边缘 margin' },
      { type: 'paragraph', text: 'CSS Box Model Level 4 引入了 `margin-trim` 属性，允许**容器**裁剪子元素靠近容器边缘的 margin。这解决了一个常见问题：容器的第一个子元素的 `margin-top` 和最后一个子元素的 `margin-bottom` 会在容器边缘创建不必要的间距。' },
      { type: 'code', code: '/* 容器裁剪子元素边缘 margin */\n.container {\n  margin-trim: block;  /* 裁剪块方向（上下）的边缘 margin */\n  padding: 20px;\n}\n\n.container > :first-child {\n  margin-top: 30px;    /* 被裁剪，不影响容器内部布局 */\n}\n\n.container > :last-child {\n  margin-bottom: 30px; /* 被裁剪 */\n}', lang: 'css', caption: 'margin-trim 裁剪容器边缘的 margin' },
      { type: 'warning', text: '`margin-trim` 是较新特性，浏览器支持有限。使用前请检查兼容性。' },
      { type: 'list', items: [
        'margin 在 border 外围创建透明空间，用于盒子间的间距',
        'margin 允许负值，可以用于重叠布局或抵消间距',
        '百分比 margin 相对于包含块的**宽度**（包括垂直方向）',
        '`margin: auto` 可以实现块级元素的水平居中',
        '垂直 margin 对非替换行内元素无效',
        'block layout 中相邻的垂直 margin 会折叠（第 6 节详解）',
        'margin-trim 允许容器裁剪子元素边缘的 margin'
      ] },
      { type: 'tip', text: 'margin 折叠是 CSS 最复杂的特性之一。如果你遇到「margin 消失了」或「margin 没有相加」的情况，很可能是折叠机制在起作用。' },
    ] as TutorialBlock[],
  },
  {
    id: 'paddings',
    number: '4',
    title: { zh: '内边距', en: 'Padding' },
    specId: 'paddings',
    summary: {
      zh: 'Padding 在 content edge 和 padding edge 之间提供间距。支持 padding-top/right/bottom/left 和 padding 简写。',
      en: 'Padding provides spacing between content edge and padding edge. Supports padding-top/right/bottom/left and padding shorthand.',
    },
    keyPoints: [
      'padding 初始值为 0,不可继承',
      '不允许负值(与 margin 不同)',
      '百分比相对于包含块的逻辑宽度(包括 padding-top/padding-bottom)',
      '背景默认绘制到 padding edge,可通过 background-origin/background-clip 调整',
      '背景同时在 border area 下方绘制(即延伸到 border 之下)',
      '简写 padding 的值语法与 margin 相同:1值=全部,2值=上下/左右,3值=上/左右/下,4值=上/右/下/左',
      '适用于除 table-row-group、table-header/footer-group、table-row、table-column(-group) 之外的所有元素(table cells 可用)',
      '也不适用于 ruby base containers 和 ruby annotation containers(CSS Box 4)',
      '如果包含块的宽度依赖于当前元素,则百分比 padding 的布局结果在 CSS2 中未定义',
      'padding 的 computed value 为计算后的 <length-percentage> 值',
    ],
    tutorial: [
      { type: 'heading', text: 'padding 的作用：内容与边框的间距' },
      { type: 'paragraph', text: '**padding**（内边距）在盒子的 content edge 和 padding edge 之间创建空间，将内容与边框分隔开。与 margin 不同，padding 是盒子视觉部分的一部分——它会显示背景色或背景图片。padding 的主要用途是控制内容的「呼吸空间」：按钮文字与边框的距离、卡片内容与卡片边缘的间距、输入框文字与边框的距离。' },
      { type: 'code', code: '/* padding 的四个方向 */\n.box {\n  padding-top: 20px;      /* 内容上方留出 20px */\n  padding-right: 15px;    /* 内容右侧留出 15px */\n  padding-bottom: 20px;   /* 内容下方留出 20px */\n  padding-left: 15px;     /* 内容左侧留出 15px */\n  background: lightblue;  /* 背景延伸到 padding area */\n}', lang: 'css', caption: 'padding 的 longhand 属性' },
      { type: 'heading', text: 'padding 简写：与 margin 相同的语法' },
      { type: 'paragraph', text: '`padding` 简写属性的值语法与 `margin` 完全相同——接受 1 到 4 个值，按顺时针方向（上 → 右 → 下 → 左）应用。' },
      { type: 'code', code: '/* padding 简写示例 */\npadding: 20px;               /* 四个方向都是 20px */\npadding: 20px 15px;          /* 上下 20px，左右 15px */\npadding: 20px 15px 10px;     /* 上 20px，左右 15px，下 10px */\npadding: 20px 15px 10px 5px; /* 上右下左（顺时针）*/', lang: 'css', caption: 'padding 简写的 1-4 值语法' },
      { type: 'heading', text: 'padding 不允许负值' },
      { type: 'paragraph', text: '与 margin 不同，**padding 不允许负值**。如果你设置了负的 padding 值（如 `padding: -10px`），浏览器会将这条声明视为无效并忽略它。padding 代表「内部空间」，负的内部空间在语义上没有意义。' },
      { type: 'warning', text: '`padding: -10px` 是无效声明，会被浏览器完全忽略。如果你发现 padding 没有生效，检查是否误写了负值。' },
      { type: 'example', title: '无效的负 padding', code: '.invalid {\n  padding: -20px;  /* ✗ 无效，整条声明被忽略 */\n  padding: 10px;   /* 这条会生效 */\n}', lang: 'css', explanation: '负 padding 声明无效，不会应用到元素。' },
      { type: 'heading', text: '百分比 padding 相对于包含块的宽度' },
      { type: 'paragraph', text: '与 margin 相同，padding 可以使用百分比值，**包括垂直方向的 `padding-top` 和 `padding-bottom`**。关键点：**所有方向的百分比都相对于包含块的宽度**，而不是高度。这与 margin 的行为一致，目的是避免循环依赖。' },
      { type: 'code', code: '/* 百分比 padding 的计算 */\n.container {\n  width: 400px;\n  height: 600px;\n}\n\n.box {\n  padding-top: 10%;     /* 10% × 400px(容器宽度) = 40px */\n  padding-bottom: 10%;  /* 10% × 400px = 40px，不是 60px */\n  padding-left: 5%;     /* 5% × 400px = 20px */\n}', lang: 'css', caption: '垂直 padding 百分比也相对于宽度' },
      { type: 'tip', text: '这个特性可以用来创建固定宽高比的盒子！例如 `padding-bottom: 56.25%` 可以创建 16:9 的宽高比容器（常用于响应式视频嵌入）。' },
      { type: 'example', title: '创建固定宽高比容器', code: '.video-container {\n  position: relative;\n  width: 100%;           /* 宽度响应式 */\n  padding-bottom: 56.25%; /* 高度 = 宽度 × 56.25% = 16:9 */\n  height: 0;             /* 内容由绝对定位子元素填充 */\n}\n\n.video-container > iframe {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}', lang: 'css', explanation: '利用百分比 padding 创建响应式的 16:9 容器。' },
      { type: 'heading', text: 'padding 与背景' },
      { type: 'paragraph', text: '**背景默认延伸到 padding edge**——`background-color` 和 `background-image` 会绘制在 padding area 内。实际上，背景还会延伸到 border area 下方（如果 border 是半透明的，背景会透过显示）。你可以通过 `background-clip` 属性控制背景的绘制区域。' },
      { type: 'code', code: '/* 背景延伸到 padding area */\n.box {\n  padding: 20px;\n  background: yellow;  /* 背景填充 padding + content */\n  border: 5px solid rgba(0,0,0,0.3);\n  /* 黄色背景会延伸到半透明边框下方 */\n}', lang: 'css', caption: '背景默认绘制到 padding edge' },
      { type: 'code', code: '/* 通过 background-clip 控制背景绘制 */\n.clip-to-content {\n  padding: 20px;\n  background: yellow;\n  background-clip: content-box;  /* 背景只在 content area */\n  /* padding area 不显示背景 */\n}\n\n.clip-to-border {\n  padding: 20px;\n  background: yellow;\n  background-clip: border-box;  /* 默认值，延伸到 border */\n}', lang: 'css', caption: 'background-clip 控制背景裁剪区域' },
      { type: 'tip', text: '`background-origin` 控制背景图片的起始位置（从哪个 box 开始平铺/定位），`background-clip` 控制背景的裁剪区域（绘制到哪个 box）。两者常配合使用。' },
      { type: 'heading', text: 'padding 不影响 margin 折叠' },
      { type: 'paragraph', text: 'padding 会阻止父元素与子元素之间的 margin 折叠。如果父元素有 padding（或 border），子元素的 margin 不会与父元素的 margin 折叠。这是控制 margin 折叠的常用技巧之一。' },
      { type: 'example', title: 'padding 阻止 margin 折叠', code: '/* 没有 padding：子元素 margin 与父元素折叠 */\n.parent {\n  margin-top: 20px;\n}\n.child {\n  margin-top: 30px;  /* 会与父元素折叠，实际间距 30px */\n}\n\n/* 有 padding：不折叠 */\n.parent {\n  margin-top: 20px;\n  padding-top: 1px;  /* 哪怕 1px 也能阻止折叠 */\n}\n.child {\n  margin-top: 30px;  /* 不与父元素折叠 */\n}', lang: 'css', explanation: 'padding 在父子元素之间创建了「分隔」，阻止 margin 折叠。' },
      { type: 'heading', text: 'padding 的适用范围' },
      { type: 'paragraph', text: 'padding 属性**几乎适用于所有元素**，但有少数例外：table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-column 等内部表格元素不支持 padding（但 table cells 支持）。CSS Box 4 还排除了 ruby base containers 和 ruby annotation containers。' },
      { type: 'tip', text: '对于行内元素（inline），垂直 padding 会显示背景但不影响行高——相邻行的内容可能与 padding 重叠。如果需要避免重叠，使用 `display: inline-block`。' },
      { type: 'code', code: '/* 行内元素的垂直 padding */\n.inline {\n  display: inline;\n  padding: 20px 10px;  /* 垂直 padding 显示背景但不撑开行 */\n  background: yellow;\n}\n\n/* inline-block 的垂直 padding 会撑开行 */\n.inline-block {\n  display: inline-block;\n  padding: 20px 10px;  /* 垂直 padding 撑开行高 */\n  background: yellow;\n}', lang: 'css', caption: '行内元素的 padding 行为' },
      { type: 'heading', text: '循环依赖问题' },
      { type: 'paragraph', text: '如果包含块的宽度依赖于当前元素（如浮动元素、绝对定位元素），百分比 padding 的布局结果在 CSS2 中是未定义的。实际浏览器通常会计算为 0 或产生不可预测的结果。避免在这种场景下使用百分比 padding。' },
      { type: 'warning', text: '浮动元素或收缩适应（shrink-to-fit）的元素使用百分比 padding 时可能产生意外结果。优先使用绝对长度（如 `20px`）。' },
      { type: 'list', items: [
        'padding 在 content 和 border 之间创建空间，会显示背景',
        'padding 不允许负值（与 margin 不同）',
        '百分比 padding 相对于包含块的**宽度**（包括垂直方向）',
        '背景默认延伸到 padding edge，可通过 background-clip 控制',
        'padding 会阻止父子元素之间的 margin 折叠',
        '几乎适用于所有元素，少数表格内部元素除外',
        '行内元素的垂直 padding 显示背景但不影响行高'
      ] },
      { type: 'tip', text: 'padding 是控制元素视觉密度的关键工具。按钮、卡片、输入框的「舒适感」很大程度上取决于合适的 padding 设置。' },
    ] as TutorialBlock[],
  },
  {
    id: 'borders',
    number: '5',
    title: { zh: '边框', en: 'Borders' },
    specId: 'borders',
    summary: {
      zh: 'Border 填充 border area,用于可视化标记盒子的边缘。边框属性包括宽度、样式和颜色,定义在 css-backgrounds-3 中。',
      en: 'Border fills the border area, used to visually mark the edges of boxes. Border properties including width, style, and color are defined in css-backgrounds-3.',
    },
    keyPoints: [
      '边框属性(width、style、color)定义在 CSS Backgrounds and Borders 模块中',
      '逻辑方向的边框属性定义在 css-logical-1 中',
      'border area 位于 padding edge 和 border edge 之间',
      'border-style 初始值为 none,因此默认不可见;必须先设置 style 才能显示边框',
      'border-width 支持 thin/medium/thick 关键字和 <length>;不允许负值',
      "border-style 为 'none' 或 'hidden' 时,computed border-width 强制为 0",
      'border-color 未指定时默认取元素 color 属性的值(currentColor)',
      'border-style 共 10 种:none、hidden、dotted、dashed、solid、double、groove、ridge、inset、outset',
      'border 简写不能为四侧分别设置不同值(与 margin/padding 不同),需要使用 border-top 等单侧简写',
      '所有边框绘制在盒子背景之上;groove/ridge/inset/outset 的颜色由 UA 算法基于 border-color 计算',
    ],
    tutorial: [
      { type: 'heading', text: 'border 的三要素：宽度、样式、颜色' },
      { type: 'paragraph', text: '**border**（边框）填充盒子的 border area，用于可视化标记盒子的边缘。边框由三个属性控制：**宽度**（`border-width`）、**样式**（`border-style`）、**颜色**（`border-color`）。这三个属性缺一不可——如果只设置宽度和颜色而不设置样式，边框不会显示。' },
      { type: 'code', code: '/* 边框的三要素 */\n.box {\n  border-width: 3px;         /* 宽度 */\n  border-style: solid;       /* 样式（必须设置！）*/\n  border-color: navy;        /* 颜色 */\n}\n\n/* 或者使用简写 */\n.box {\n  border: 3px solid navy;    /* 宽度 样式 颜色 */\n}', lang: 'css', caption: 'border 的三要素' },
      { type: 'warning', text: '**border-style 是必需的**！如果只设置 `border-width` 和 `border-color` 而不设置 `border-style`（或 style 为默认值 `none`），边框不会显示。这是新手最常见的错误。' },
      { type: 'heading', text: 'border-style：10 种边框样式' },
      { type: 'paragraph', text: '`border-style` 定义边框的视觉样式，共有 10 种取值。最常用的是 `solid`（实线）、`dashed`（虚线）、`dotted`（点线）和 `none`（无边框）。其他样式如 `double`、`groove`、`ridge`、`inset`、`outset` 创建 3D 效果，`hidden` 用于表格边框冲突解决。' },
      { type: 'code', code: '/* 常用边框样式 */\nborder-style: none;      /* 无边框（默认值，不显示）*/\nborder-style: solid;     /* 实线 ————————— */\nborder-style: dashed;    /* 虚线 — — — — — */\nborder-style: dotted;    /* 点线 · · · · · */\nborder-style: double;    /* 双线 ═══════ */\n\n/* 3D 效果样式（颜色由浏览器计算）*/\nborder-style: groove;    /* 凹槽效果 */\nborder-style: ridge;     /* 凸脊效果 */\nborder-style: inset;     /* 内嵌效果（整个盒子像凹进去）*/\nborder-style: outset;    /* 外凸效果（整个盒子像凸出来）*/\n\n/* 表格专用 */\nborder-style: hidden;    /* 表格边框冲突时，hidden 优先级最高 */', lang: 'css', caption: '10 种 border-style 值' },
      { type: 'tip', text: '`groove`、`ridge`、`inset`、`outset` 的 3D 效果取决于 `border-color` 和浏览器的算法——浏览器会自动计算明暗两侧的颜色来创建立体感。' },
      { type: 'heading', text: 'border-width：宽度控制' },
      { type: 'paragraph', text: '`border-width` 控制边框的宽度，可以使用具体的长度值（如 `3px`、`0.2em`）或关键字（`thin`、`medium`、`thick`）。**border-width 不允许负值**——负值会导致声明无效。如果 `border-style` 为 `none` 或 `hidden`，计算后的 `border-width` 会被强制为 0。' },
      { type: 'code', code: '/* border-width 的取值 */\nborder-width: 3px;        /* 具体长度 */\nborder-width: 0.2em;      /* 相对单位 */\nborder-width: thin;       /* 关键字（通常 1px）*/\nborder-width: medium;     /* 关键字（通常 3px，默认值）*/\nborder-width: thick;      /* 关键字（通常 5px）*/\n\n/* 四个方向分别设置 */\nborder-width: 1px 2px 3px 4px;  /* 上右下左 */', lang: 'css', caption: 'border-width 的取值' },
      { type: 'warning', text: '`thin`、`medium`、`thick` 的具体像素值由浏览器决定，不同浏览器可能不同。如果需要精确控制，使用具体长度值。' },
      { type: 'heading', text: 'border-color：颜色与 currentColor' },
      { type: 'paragraph', text: '`border-color` 控制边框的颜色。如果不显式设置，**默认值是元素的 `color` 属性值**（即 `currentColor`）。这意味着边框颜色会自动跟随文本颜色，这是一个非常实用的设计。' },
      { type: 'example', title: 'border-color 默认继承 color', code: '.box {\n  color: navy;              /* 文本颜色 */\n  border: 2px solid;        /* 边框颜色自动为 navy */\n}', lang: 'css', explanation: '省略 `border-color` 时，边框颜色自动等于 `color` 的值。' },
      { type: 'code', code: '/* 显式设置边框颜色 */\nborder-color: red;                    /* 单色 */\nborder-color: red blue;               /* 上下红，左右蓝 */\nborder-color: red blue green yellow;  /* 上右下左 */\nborder-color: transparent;            /* 透明边框 */\nborder-color: currentColor;           /* 显式使用 color 值 */', lang: 'css', caption: 'border-color 的取值' },
      { type: 'tip', text: '透明边框（`border-color: transparent`）常用于占位——边框占据空间但不可见，hover 时改变颜色可以避免布局跳动。' },
      { type: 'heading', text: 'border 简写：不同于 margin/padding' },
      { type: 'paragraph', text: '`border` 简写属性的语法与 `margin`/`padding` **不同**。`border` 一次性设置所有四个方向的宽度、样式、颜色，**无法为四个方向设置不同值**。如果需要为不同方向设置不同边框，必须使用单侧简写（`border-top`、`border-right` 等）或 longhand 属性。' },
      { type: 'code', code: '/* border 简写：应用于所有四个方向 */\nborder: 2px solid navy;  /* 四个方向都是 2px 实线 navy */\n\n/* 单侧简写：只影响一个方向 */\nborder-top: 3px dashed red;     /* 只设置上边框 */\nborder-bottom: 1px solid blue;  /* 只设置下边框 */\n\n/* 为四个方向设置不同边框 */\n.box {\n  border-top: 3px solid red;\n  border-right: 2px dashed blue;\n  border-bottom: 1px dotted green;\n  border-left: 4px double yellow;\n}', lang: 'css', caption: 'border 简写 vs 单侧简写' },
      { type: 'warning', text: '不能写 `border: 1px 2px 3px 4px solid navy;`——`border` 简写不支持为四个方向设置不同宽度。这与 `margin: 1px 2px 3px 4px;` 的语法不同。' },
      { type: 'heading', text: 'border 与背景的层叠关系' },
      { type: 'paragraph', text: '**所有边框绘制在背景之上**。背景会延伸到 border area 下方（即背景先绘制到 border edge，然后边框绘制在背景之上）。如果边框是半透明的，可以透过边框看到背景。' },
      { type: 'example', title: '半透明边框透出背景', code: '.box {\n  background: yellow;\n  border: 10px solid rgba(0, 0, 0, 0.3);  /* 半透明黑色边框 */\n}', lang: 'css', explanation: '黄色背景会延伸到边框下方，透过半透明边框显示出来。' },
      { type: 'heading', text: '四个方向独立控制' },
      { type: 'paragraph', text: 'border 的每个属性（width、style、color）都可以为四个方向单独设置。CSS 提供了丰富的 longhand 属性：`border-top-width`、`border-right-style`、`border-bottom-color` 等。' },
      { type: 'code', code: '/* 精细控制每个方向 */\n.box {\n  /* 上边框 */\n  border-top-width: 3px;\n  border-top-style: solid;\n  border-top-color: red;\n  \n  /* 右边框 */\n  border-right-width: 2px;\n  border-right-style: dashed;\n  border-right-color: blue;\n  \n  /* 下边框和左边框省略（无边框）*/\n}', lang: 'css', caption: '独立控制每个方向的每个属性' },
      { type: 'code', code: '/* border-width/style/color 可以接受 1-4 个值 */\nborder-style: solid dashed;  /* 上下实线，左右虚线 */\nborder-width: 1px 2px 3px;   /* 上 1px，左右 2px，下 3px */\nborder-color: red blue green yellow;  /* 上右下左 */', lang: 'css', caption: 'border-width/style/color 的简写' },
      { type: 'heading', text: '边框属性定义在 CSS Backgrounds and Borders' },
      { type: 'paragraph', text: '虽然边框是盒模型的一部分，但边框的详细定义（包括 `border-radius`、`border-image`、阴影等）在 **CSS Backgrounds and Borders Level 3** 模块中，而非 CSS Box Model 模块。逻辑方向的边框属性（如 `border-block-start`）则定义在 **CSS Logical Properties** 模块中。' },
      { type: 'tip', text: 'CSS 的模块化设计让相关特性分散在不同规范中。盒模型定义基础结构，Backgrounds and Borders 定义视觉装饰，Logical Properties 定义流相对属性。' },
      { type: 'heading', text: '实用技巧' },
      { type: 'code', code: '/* 技巧 1：只显示部分边框 */\n.underline {\n  border-bottom: 2px solid navy;  /* 只有下边框 */\n}\n\n/* 技巧 2：透明边框占位，hover 显示 */\n.card {\n  border: 2px solid transparent;  /* 占据 2px 空间但不可见 */\n}\n.card:hover {\n  border-color: blue;  /* hover 时显示，无布局跳动 */\n}\n\n/* 技巧 3：边框跟随文本颜色 */\n.button {\n  color: navy;\n  border: 2px solid;  /* 自动使用 navy（currentColor）*/\n}\n.button.danger {\n  color: red;  /* 边框也变红 */\n}', lang: 'css', caption: '边框的实用技巧' },
      { type: 'list', items: [
        'border 由宽度、样式、颜色三要素组成，**样式是必需的**',
        'border-style 有 10 种取值，最常用 solid、dashed、dotted、none',
        'border-color 默认继承 color 属性值（currentColor）',
        'border 简写应用于所有四个方向，不能像 margin 那样设置不同值',
        '边框绘制在背景之上，半透明边框可以透出背景',
        '边框属性详细定义在 CSS Backgrounds and Borders 模块中',
        '透明边框可以用于占位，避免 hover 时的布局跳动'
      ] },
      { type: 'tip', text: '边框是盒模型中最「有存在感」的部分——它既占据空间又有视觉呈现。合理使用边框可以清晰划分界面区域，提升可读性。' },
    ] as TutorialBlock[],
  },
  {
    id: 'margin-collapsing',
    number: '6',
    title: { zh: '外边距折叠详解', en: 'Margin Collapsing in Detail' },
    summary: {
      zh: 'CSS2 §8.3.1 定义的外边距折叠(margin collapsing)规则。相邻的垂直外边距会折叠为单个外边距,遵循特定条件和计算规则。',
      en: 'Margin collapsing rules defined in CSS2 §8.3.1. Adjacent vertical margins collapse into a single margin following specific conditions and calculation rules.',
    },
    keyPoints: [
      '外边距折叠(margin collapsing)仅发生在垂直方向(block-start/block-end)的相邻 margin 之间,水平 margin 永远不折叠',
      '两个 margin 相邻(adjoining)的条件:它们属于同一个 BFC 中的流内(in-flow)块级盒子,没有行盒(line box)、清除(clearance)、padding 或 border 将它们分隔',
      '三种折叠场景:兄弟元素(sibling)的相邻 margin 折叠;父元素与第一个/最后一个子元素的 margin 折叠(当无 border/padding/BFC 隔开时);空元素自身的 margin-top 和 margin-bottom 折叠',
      '折叠结果:两个正 margin 取较大值;两个负 margin 取绝对值较大者(更负的那个);一正一负则正值减去负值的绝对值',
      '建立新 BFC 的元素不会与其子元素的 margin 折叠(如 overflow: hidden、display: flow-root)',
      '浮动元素的 margin 不与任何 margin 折叠',
      '绝对定位(absolute/fixed)元素的 margin 不与任何 margin 折叠',
      'inline-block 元素的 margin 不与任何 margin 折叠',
      '清除浮动(clearance)会阻止折叠:有 clearance 的元素,其 margin-top 不与上方的 margin 折叠',
      '根元素的 margin 不折叠',
      '空元素(高度为 0,无 padding/border/行内内容/BFC)的 margin-top 和 margin-bottom 相互折叠;如果该空元素的 margin 再与兄弟 margin 相邻,则继续折叠',
      '多个 margin 可以链式折叠:如果 A 的 margin-bottom 与 B(空元素)的 margin-top 折叠,B 自身折叠,B 的 margin-bottom 又与 C 的 margin-top 折叠,最终结果是所有参与折叠的 margin 中的最大正值减去最大负值的绝对值',
      'Flex 容器和 Grid 容器的子项目之间不会发生传统的 margin 折叠,因为 flex/grid 格式化上下文不是 BFC',
    ],
    tutorial: [
      { type: 'heading', text: 'margin 折叠：CSS 中最容易被误解的特性' },
      { type: 'paragraph', text: '**margin 折叠**（margin collapsing）是 CSS 中最反直觉的特性之一。当两个垂直方向的 margin 相邻时，它们会「折叠」（collapse）成一个 margin，而不是简单相加。例如，上方元素的 `margin-bottom: 30px` 和下方元素的 `margin-top: 20px` 不会产生 50px 的间距，而是折叠为 30px。理解 margin 折叠的规则是掌握 CSS 布局的关键。' },
      { type: 'example', title: '基本的 margin 折叠', code: '<div class="box1" style="margin-bottom: 30px;">Box 1</div>\n<div class="box2" style="margin-top: 20px;">Box 2</div>\n<!-- 两个盒子之间的实际间距是 30px，不是 50px -->', lang: 'html', explanation: '相邻的垂直 margin 折叠为单个 margin，取两者中的较大值。' },
      { type: 'heading', text: '折叠的基本条件' },
      { type: 'paragraph', text: 'margin 折叠**仅发生在垂直方向**（block-start 和 block-end），水平方向的 margin 永远不折叠。两个 margin 必须是**相邻的**（adjoining）——它们之间没有 border、padding、line box（行盒）或 clearance（清除）分隔，且都属于同一个 BFC 中的 in-flow 块级盒子。' },
      { type: 'warning', text: '水平方向的 margin **永远不折叠**。`margin-left` 和 `margin-right` 总是简单相加。折叠只发生在垂直方向（或者说，block 方向）。' },
      { type: 'heading', text: '三种折叠场景' },
      { type: 'list', ordered: true, items: [
        '**兄弟元素之间**：相邻的兄弟元素的 `margin-bottom` 和 `margin-top` 折叠',
        '**父元素与第一个子元素**：父元素的 `margin-top` 与第一个子元素的 `margin-top` 折叠（如果之间没有 border/padding/BFC 分隔）',
        '**父元素与最后一个子元素**：父元素的 `margin-bottom` 与最后一个子元素的 `margin-bottom` 折叠',
        '**空元素自身**：高度为 0 且没有 border/padding 的空元素，其 `margin-top` 和 `margin-bottom` 相互折叠'
      ] },
      { type: 'heading', text: '场景 1：兄弟元素的 margin 折叠' },
      { type: 'code', code: '/* HTML */\n<div class="sibling1">第一个盒子</div>\n<div class="sibling2">第二个盒子</div>\n\n/* CSS */\n.sibling1 { margin-bottom: 40px; }\n.sibling2 { margin-top: 30px; }\n\n/* 结果：两个盒子之间的间距是 40px（取较大值）*/', lang: 'css', caption: '兄弟元素的 margin 折叠' },
      { type: 'heading', text: '场景 2：父元素与第一个子元素的 margin 折叠' },
      { type: 'paragraph', text: '这是最容易让人困惑的场景。如果父元素没有 border-top、padding-top，且没有建立新的 BFC，子元素的 `margin-top` 会「逃逸」出父元素，与父元素的 `margin-top` 折叠。结果是子元素的 margin 应用到父元素上方。' },
      { type: 'example', title: '子元素 margin 逃逸', code: '<div class="parent">\n  <div class="child">子元素</div>\n</div>\n\n/* CSS */\n.parent {\n  margin-top: 20px;\n  background: lightblue;\n}\n.child {\n  margin-top: 40px;  /* 会与父元素的 margin-top 折叠 */\n}\n\n/* 结果：父元素上方有 40px 间距，子元素紧贴父元素顶部 */', lang: 'html', explanation: '子元素的 margin-top 与父元素的 margin-top 折叠，最终间距应用到父元素上方。' },
      { type: 'heading', text: '如何阻止父子 margin 折叠' },
      { type: 'code', code: '/* 方法 1：给父元素添加 border */\n.parent {\n  border-top: 1px solid transparent;  /* 哪怕透明也行 */\n}\n\n/* 方法 2：给父元素添加 padding */\n.parent {\n  padding-top: 1px;  /* 哪怕 1px 也能阻止折叠 */\n}\n\n/* 方法 3：让父元素建立新的 BFC */\n.parent {\n  overflow: hidden;         /* 或 auto、scroll */\n  /* 或 */ display: flow-root;  /* 专门用于建立 BFC */\n}', lang: 'css', caption: '阻止父子 margin 折叠的三种方法' },
      { type: 'tip', text: '`display: flow-root` 是专门为建立 BFC 而设计的值，它唯一的作用就是创建 BFC，没有其他副作用。比 `overflow: hidden` 更语义化。' },
      { type: 'heading', text: '场景 3：空元素自身的 margin 折叠' },
      { type: 'paragraph', text: '如果一个元素高度为 0（`height` 为 0 或 auto 且没有内容），没有 border、padding，没有建立 BFC，其 `margin-top` 和 `margin-bottom` 会相互折叠。这个折叠后的 margin 还可能继续与相邻的 margin 折叠。' },
      { type: 'code', code: '/* 空元素的 margin 折叠 */\n.empty {\n  margin-top: 30px;\n  margin-bottom: 40px;\n  /* 没有内容、border、padding */\n}\n\n/* 结果：元素自身的 margin-top 和 margin-bottom 折叠为 40px\n   这个 40px 还会与上方和下方元素的 margin 继续折叠 */', lang: 'css', caption: '空元素的双向折叠' },
      { type: 'heading', text: '折叠值的计算规则' },
      { type: 'list', items: [
        '**两个正 margin**：取较大值（如 30px 和 20px 折叠为 30px）',
        '**两个负 margin**：取绝对值较大的负值（如 -30px 和 -20px 折叠为 -30px）',
        '**一正一负**：正值减去负值的绝对值（如 30px 和 -20px 折叠为 10px）',
        '**多个 margin 链式折叠**：最大正值减去最大负值的绝对值'
      ] },
      { type: 'code', code: '/* 折叠计算示例 */\n/* 场景 1：两个正值 */\nmargin-bottom: 50px;  /* 元素 A */\nmargin-top: 30px;     /* 元素 B */\n/* 结果：50px（取较大值）*/\n\n/* 场景 2：一正一负 */\nmargin-bottom: 40px;   /* 元素 A */\nmargin-top: -20px;     /* 元素 B */\n/* 结果：20px（40 - 20）*/\n\n/* 场景 3：两个负值 */\nmargin-bottom: -30px;  /* 元素 A */\nmargin-top: -50px;     /* 元素 B */\n/* 结果：-50px（绝对值较大的负值）*/', lang: 'css', caption: 'margin 折叠的计算规则' },
      { type: 'heading', text: '哪些情况不会折叠' },
      { type: 'list', items: [
        '**水平 margin**：`margin-left` 和 `margin-right` 永远不折叠',
        '**浮动元素**：`float: left/right` 的元素的 margin 不与任何 margin 折叠',
        '**绝对定位元素**：`position: absolute/fixed` 的元素的 margin 不折叠',
        '**inline-block 元素**：`display: inline-block` 的元素的 margin 不折叠',
        '**建立新 BFC 的元素**：不会与其子元素的 margin 折叠',
        '**Flexbox/Grid 子项**：flex 容器或 grid 容器的子项之间不折叠（因为它们不在 BFC 中）',
        '**根元素**：`<html>` 元素的 margin 不折叠',
        '**有 clearance 的元素**：清除浮动产生的 clearance 会阻止 margin 折叠'
      ] },
      { type: 'code', code: '/* 这些情况不会发生 margin 折叠 */\n\n/* Flexbox 子项 */\n.flex-container {\n  display: flex;\n  flex-direction: column;\n}\n.flex-item {\n  margin: 20px 0;  /* 不会折叠，间距是 40px */\n}\n\n/* Grid 子项 */\n.grid-container {\n  display: grid;\n}\n.grid-item {\n  margin: 20px 0;  /* 不会折叠 */\n}\n\n/* 浮动元素 */\n.float {\n  float: left;\n  margin-bottom: 30px;  /* 不与下方元素的 margin 折叠 */\n}', lang: 'css', caption: '不发生折叠的场景' },
      { type: 'heading', text: '实用调试技巧' },
      { type: 'paragraph', text: '当你发现「margin 消失了」或「间距不对」时，很可能是 margin 折叠在起作用。调试技巧：给父元素添加 `border: 1px solid red` 或 `padding: 1px`，看看间距是否恢复正常。如果恢复了，说明是父子 margin 折叠导致的。' },
      { type: 'tip', text: '现代布局（Flexbox、Grid）不会发生传统的 margin 折叠，这是它们相比传统 block layout 的一大优势——行为更可预测。' },
      { type: 'warning', text: 'margin 折叠是 CSS2 为了优化排版而设计的特性（如段落之间的间距不会因为上下 margin 而翻倍）。但它的规则复杂，容易造成困惑。如果你觉得难以理解，可以通过建立 BFC 或使用 Flexbox/Grid 来避免折叠。' },
      { type: 'list', items: [
        'margin 折叠只发生在垂直方向（block 方向），水平永不折叠',
        '三种折叠场景：兄弟、父子、空元素自身',
        '折叠值计算：正值取大，负值取绝对值大者，一正一负相减',
        '父子折叠可通过 border、padding 或建立 BFC 阻止',
        'Flexbox 和 Grid 的子项不会发生传统 margin 折叠',
        '浮动、绝对定位、inline-block 元素的 margin 不折叠',
        '遇到「margin 消失」问题时，优先考虑是否是折叠导致'
      ] },
    ] as TutorialBlock[],
  },
  {
    id: 'logical-properties',
    number: '7',
    title: { zh: '逻辑属性与值', en: 'CSS Logical Properties & Values' },
    summary: {
      zh: 'CSS 逻辑属性使用相对于文本流方向的 block/inline 维度替代物理方向(top/right/bottom/left),使样式能自动适应不同的书写模式和方向。',
      en: 'CSS Logical Properties use flow-relative block/inline dimensions instead of physical directions (top/right/bottom/left), enabling styles to automatically adapt to different writing modes and directions.',
    },
    keyPoints: [
      '逻辑属性基于两个维度:block(块方向,段落堆叠方向)和 inline(行内方向,文本书写方向)',
      '物理到逻辑的映射(水平 LTR 书写模式下):top → block-start, bottom → block-end, left → inline-start, right → inline-end',
      'margin 逻辑属性:margin-block-start/end、margin-inline-start/end、margin-block(简写)、margin-inline(简写)',
      'padding 逻辑属性:padding-block-start/end、padding-inline-start/end、padding-block(简写)、padding-inline(简写)',
      'border 逻辑属性:border-block-start/end-width/style/color、border-inline-start/end-width/style/color、border-block/border-inline 简写',
      '尺寸逻辑属性:inline-size(对应 width)、block-size(对应 height)、min-inline-size、max-inline-size、min-block-size、max-block-size',
      'inset 逻辑属性:inset-block-start/end、inset-inline-start/end、inset-block(简写)、inset-inline(简写)',
      '逻辑属性的值会根据元素的 writing-mode、direction 和 text-orientation 解析为物理值',
      'float 和 clear 也有逻辑值:float: inline-start/inline-end,clear: inline-start/inline-end',
      'text-align 逻辑值:start 和 end 替代 left 和 right',
      'resize 逻辑值:block 和 inline',
      '逻辑属性与物理属性控制同一组底层属性,优先级由正常的层叠规则决定,最后声明的胜出',
      '逻辑属性对国际化(i18n)至关重要:同一套样式可自动适配 LTR(如英语)、RTL(如阿拉伯语)和垂直书写(如传统中文)',
    ],
    tutorial: [
      { type: 'heading', text: '逻辑属性：为国际化而生' },
      { type: 'paragraph', text: 'CSS 传统的**物理属性**（physical properties）使用固定的物理方向——`top`、`right`、`bottom`、`left` 直接对应屏幕的上下左右。这在水平从左到右（LTR）的书写模式（如英语）中运作良好，但在从右到左（RTL）的语言（如阿拉伯语、希伯来语）或垂直书写（如传统中文、日文）中会导致问题。**逻辑属性**（logical properties）使用相对于文本流方向的维度——`block`（块方向）和 `inline`（行内方向），使样式能够自动适应不同的书写模式。' },
      { type: 'heading', text: '两个维度：block 与 inline' },
      { type: 'paragraph', text: '逻辑属性基于两个维度：**block 维度**（块方向）是段落堆叠的方向，**inline 维度**（行内方向）是文本书写的方向。在水平 LTR 模式下，block 方向是垂直的（段落从上到下堆叠），inline 方向是水平的（文本从左到右书写）。但在不同书写模式下，这些方向会改变。' },
      { type: 'code', code: '/* 水平 LTR（英语）的映射 */\nwriting-mode: horizontal-tb;  /* 默认值 */\ndirection: ltr;               /* 默认值 */\n\n/* 逻辑到物理的映射：\n   block-start  → top      (段落从上开始)\n   block-end    → bottom   (段落向下堆叠)\n   inline-start → left     (文本从左开始)\n   inline-end   → right    (文本向右延伸)\n*/', lang: 'css', caption: '水平 LTR 模式的逻辑到物理映射' },
      { type: 'code', code: '/* 水平 RTL（阿拉伯语）的映射 */\nwriting-mode: horizontal-tb;\ndirection: rtl;\n\n/* 逻辑到物理的映射：\n   block-start  → top      (段落仍从上开始)\n   block-end    → bottom\n   inline-start → right    (文本从右开始！)\n   inline-end   → left     (文本向左延伸)\n*/', lang: 'css', caption: '水平 RTL 模式的映射' },
      { type: 'heading', text: 'margin 的逻辑属性' },
      { type: 'paragraph', text: 'margin 的逻辑属性用 `-block-start`、`-block-end`、`-inline-start`、`-inline-end` 替代 `-top`、`-bottom`、`-left`、`-right`。还有简写属性 `margin-block` 和 `margin-inline`。' },
      { type: 'code', code: '/* 物理属性（固定方向）*/\n.box {\n  margin-top: 20px;\n  margin-right: 10px;\n  margin-bottom: 20px;\n  margin-left: 10px;\n}\n\n/* 逻辑属性（相对于文本流）*/\n.box {\n  margin-block-start: 20px;   /* 块方向起始侧 */\n  margin-inline-end: 10px;    /* 行内方向结束侧 */\n  margin-block-end: 20px;     /* 块方向结束侧 */\n  margin-inline-start: 10px;  /* 行内方向起始侧 */\n}\n\n/* 简写 */\n.box {\n  margin-block: 20px;    /* 块方向两侧都是 20px */\n  margin-inline: 10px;   /* 行内方向两侧都是 10px */\n}', lang: 'css', caption: 'margin 的物理属性 vs 逻辑属性' },
      { type: 'heading', text: 'padding 和 border 的逻辑属性' },
      { type: 'paragraph', text: 'padding 和 border 也有对应的逻辑属性，语法与 margin 一致。border 的逻辑属性还包括 `-width`、`-style`、`-color` 的后缀。' },
      { type: 'code', code: '/* padding 逻辑属性 */\n.box {\n  padding-block: 20px;     /* 上下（或块方向两侧）*/\n  padding-inline: 15px;    /* 左右（或行内方向两侧）*/\n}\n\n/* border 逻辑属性 */\n.box {\n  border-block-start: 2px solid navy;  /* 上边框（或块起始侧）*/\n  border-inline-end-width: 3px;        /* 右边框宽度（或行内结束侧）*/\n  border-inline-start-color: red;      /* 左边框颜色 */\n}', lang: 'css', caption: 'padding 和 border 的逻辑属性' },
      { type: 'heading', text: '尺寸的逻辑属性' },
      { type: 'paragraph', text: '`inline-size` 对应 `width`（行内方向的尺寸），`block-size` 对应 `height`（块方向的尺寸）。在水平书写模式下，`inline-size` 就是宽度，`block-size` 就是高度。但在垂直书写模式下，映射会颠倒。' },
      { type: 'code', code: '/* 水平 LTR 模式 */\n.box {\n  inline-size: 300px;   /* = width: 300px */\n  block-size: 200px;    /* = height: 200px */\n  min-inline-size: 100px;  /* = min-width: 100px */\n  max-block-size: 500px;   /* = max-height: 500px */\n}', lang: 'css', caption: '尺寸的逻辑属性' },
      { type: 'heading', text: '为什么要使用逻辑属性' },
      { type: 'paragraph', text: '逻辑属性的最大优势是**国际化**（i18n）。同一套样式可以自动适配不同的书写模式和文本方向，无需为每种语言编写单独的 CSS。' },
      { type: 'example', title: '自动适配 RTL', code: '/* 使用物理属性：需要为 RTL 单独写样式 */\n.button {\n  padding-left: 40px;  /* 图标在左侧 */\n}\n[dir="rtl"] .button {\n  padding-left: 0;\n  padding-right: 40px;  /* RTL 时图标在右侧 */\n}\n\n/* 使用逻辑属性：自动适配 */\n.button {\n  padding-inline-start: 40px;  /* 文本起始侧留空间 */\n  /* LTR 时自动映射到 left，RTL 时自动映射到 right */\n}', lang: 'css', explanation: '逻辑属性自动根据 `direction` 属性调整，无需手动适配。' },
      { type: 'heading', text: '逻辑属性与物理属性的关系' },
      { type: 'paragraph', text: '逻辑属性和物理属性**控制同一组底层属性**——它们不是独立的两套系统，而是同一组 margin/padding/border 的不同访问方式。当两者同时声明时，遵循正常的层叠规则——**后声明的覆盖先声明的**。' },
      { type: 'code', code: '/* 逻辑属性和物理属性会覆盖 */\n.box {\n  margin-left: 20px;          /* 物理属性 */\n  margin-inline-start: 30px;  /* 逻辑属性，在 LTR 下对应 left */\n  /* 结果：左侧 margin 是 30px（后声明覆盖先声明）*/\n}\n\n.box2 {\n  margin-inline-start: 30px;  /* 逻辑属性 */\n  margin-left: 20px;          /* 物理属性 */\n  /* 结果：左侧 margin 是 20px（后声明覆盖）*/\n}', lang: 'css', caption: '逻辑属性与物理属性遵循层叠规则' },
      { type: 'warning', text: '不要在同一个规则集中混用逻辑属性和物理属性——这会导致维护困难。选择一种风格并坚持使用。' },
      { type: 'heading', text: '其他逻辑属性和值' },
      { type: 'list', items: [
        '**inset 逻辑属性**：`inset-block-start`、`inset-inline-end` 等（用于定位）',
        '**float 逻辑值**：`float: inline-start` 和 `float: inline-end`',
        '**clear 逻辑值**：`clear: inline-start` 和 `clear: inline-end`',
        '**text-align 逻辑值**：`text-align: start` 和 `text-align: end` 替代 `left` 和 `right`',
        '**resize 逻辑值**：`resize: block` 和 `resize: inline`'
      ] },
      { type: 'code', code: '/* 定位的逻辑属性 */\n.positioned {\n  position: absolute;\n  inset-block-start: 20px;   /* top（LTR）或 right（垂直）*/\n  inset-inline-end: 10px;    /* right（LTR）或 bottom（垂直）*/\n}\n\n/* text-align 逻辑值 */\n.text {\n  text-align: start;  /* LTR 时对齐到左侧，RTL 时对齐到右侧 */\n}', lang: 'css', caption: '其他逻辑属性和值' },
      { type: 'heading', text: '实用建议' },
      { type: 'tip', text: '如果你的网站需要支持多语言（特别是 RTL 语言），优先使用逻辑属性。即使当前只支持英语，使用逻辑属性也能让未来的国际化更轻松。' },
      { type: 'code', code: '/* 推荐：使用逻辑属性 */\n.card {\n  margin-block: 20px;              /* 垂直方向 margin */\n  padding-inline: 15px;            /* 水平方向 padding */\n  border-inline-start: 3px solid;  /* 文本起始侧边框 */\n}\n\n/* 避免：混用逻辑和物理属性 */\n.card {\n  margin-top: 20px;         /* 物理 */\n  padding-inline: 15px;     /* 逻辑 */\n  border-left: 3px solid;   /* 物理 */\n  /* 风格不一致，难以维护 */\n}', lang: 'css', caption: '保持风格一致' },
      { type: 'warning', text: '逻辑属性在旧浏览器中可能不支持。如果需要兼容旧浏览器，先声明物理属性作为降级，再声明逻辑属性作为增强。' },
      { type: 'code', code: '/* 渐进增强：先物理后逻辑 */\n.box {\n  margin-left: 20px;          /* 降级方案 */\n  margin-inline-start: 20px;  /* 增强方案（覆盖前者）*/\n}', lang: 'css', caption: '使用渐进增强确保向后兼容' },
      { type: 'list', items: [
        '逻辑属性使用 block/inline 维度替代 top/right/bottom/left',
        'block 方向是段落堆叠方向，inline 方向是文本书写方向',
        '逻辑属性根据 writing-mode 和 direction 自动映射到物理方向',
        'margin、padding、border、尺寸、定位都有对应的逻辑属性',
        '逻辑属性与物理属性控制同一组底层属性，遵循层叠规则',
        '逻辑属性对国际化至关重要，让样式自动适配 LTR、RTL、垂直书写',
        '优先使用逻辑属性，保持代码风格一致'
      ] },
      { type: 'tip', text: 'CSS Logical Properties 是现代 CSS 的重要组成部分。即使你暂时不需要支持 RTL 或垂直书写，熟悉逻辑属性的概念也能帮助你更好地理解 CSS 的坐标系统。' },
    ] as TutorialBlock[],
  },
];

export const anchors: Record<string, string> = {
  'box-dimensions': 'box-model',
  'mpb-examples': 'margins',
  'collapsing-margins': 'margins',
  'bidi-box-model': 'box-model',
};

// ============================================================
// 属性定义（CSS2.2 Ch8 Box Model）
// ============================================================

const BOX = 'https://www.w3.org/TR/CSS22/box.html';
const BOX3 = 'https://www.w3.org/TR/css-box-3/';
const BG3 = 'https://www.w3.org/TR/css-backgrounds-3/';
const LOGICAL = 'https://www.w3.org/TR/css-logical-1/';
const APPLIES_MARGIN = '除 table-caption、table、inline-table 之外的 table 显示类型元素外的所有元素';
const APPLIES_PADDING = '除 table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-column 外的所有元素';

export const propertyTerms: Record<string, PropertyEntry> = {
  // ── margin ──
  'margin-top': {
    zh: '上外边距',
    value: '<margin-width> | inherit',
    initial: '0',
    appliesTo: APPLIES_MARGIN,
    inherited: false,
    percentages: '相对于包含块的宽度',
    computedValue: '指定的百分比或绝对长度',
    css2Url: `${BOX}#propdef-margin-top`,
    css3Url: BOX3,
    sectionRef: 'box-model#margins',
  },
  'margin-right': {
    zh: '右外边距',
    value: '<margin-width> | inherit',
    initial: '0',
    appliesTo: APPLIES_MARGIN,
    inherited: false,
    percentages: '相对于包含块的宽度',
    computedValue: '指定的百分比或绝对长度',
    css2Url: `${BOX}#propdef-margin-right`,
    css3Url: BOX3,
    sectionRef: 'box-model#margins',
  },
  'margin-bottom': {
    zh: '下外边距',
    value: '<margin-width> | inherit',
    initial: '0',
    appliesTo: APPLIES_MARGIN,
    inherited: false,
    percentages: '相对于包含块的宽度',
    computedValue: '指定的百分比或绝对长度',
    css2Url: `${BOX}#propdef-margin-bottom`,
    css3Url: BOX3,
    sectionRef: 'box-model#margins',
  },
  'margin-left': {
    zh: '左外边距',
    value: '<margin-width> | inherit',
    initial: '0',
    appliesTo: APPLIES_MARGIN,
    inherited: false,
    percentages: '相对于包含块的宽度',
    computedValue: '指定的百分比或绝对长度',
    css2Url: `${BOX}#propdef-margin-left`,
    css3Url: BOX3,
    sectionRef: 'box-model#margins',
  },
  'margin': {
    zh: '外边距（简写）',
    value: '<margin-width>{1,4} | inherit',
    initial: '见各子属性',
    appliesTo: APPLIES_MARGIN,
    inherited: false,
    percentages: '相对于包含块的宽度',
    computedValue: '见各子属性',
    css2Url: `${BOX}#propdef-margin`,
    css3Url: BOX3,
    sectionRef: 'box-model#margins',
  },

  // ── padding ──
  'padding-top': {
    zh: '上内边距',
    value: '<padding-width> | inherit',
    initial: '0',
    appliesTo: APPLIES_PADDING,
    inherited: false,
    percentages: '相对于包含块的宽度',
    computedValue: '指定的百分比或绝对长度',
    css2Url: `${BOX}#propdef-padding-top`,
    css3Url: BOX3,
    sectionRef: 'box-model#paddings',
  },
  'padding-right': {
    zh: '右内边距',
    value: '<padding-width> | inherit',
    initial: '0',
    appliesTo: APPLIES_PADDING,
    inherited: false,
    percentages: '相对于包含块的宽度',
    computedValue: '指定的百分比或绝对长度',
    css2Url: `${BOX}#propdef-padding-right`,
    css3Url: BOX3,
    sectionRef: 'box-model#paddings',
  },
  'padding-bottom': {
    zh: '下内边距',
    value: '<padding-width> | inherit',
    initial: '0',
    appliesTo: APPLIES_PADDING,
    inherited: false,
    percentages: '相对于包含块的宽度',
    computedValue: '指定的百分比或绝对长度',
    css2Url: `${BOX}#propdef-padding-bottom`,
    css3Url: BOX3,
    sectionRef: 'box-model#paddings',
  },
  'padding-left': {
    zh: '左内边距',
    value: '<padding-width> | inherit',
    initial: '0',
    appliesTo: APPLIES_PADDING,
    inherited: false,
    percentages: '相对于包含块的宽度',
    computedValue: '指定的百分比或绝对长度',
    css2Url: `${BOX}#propdef-padding-left`,
    css3Url: BOX3,
    sectionRef: 'box-model#paddings',
  },
  'padding': {
    zh: '内边距（简写）',
    value: '<padding-width>{1,4} | inherit',
    initial: '见各子属性',
    appliesTo: APPLIES_PADDING,
    inherited: false,
    percentages: '相对于包含块的宽度',
    computedValue: '见各子属性',
    css2Url: `${BOX}#propdef-padding`,
    css3Url: BOX3,
    sectionRef: 'box-model#paddings',
  },

  // ── border-width ──
  'border-top-width': {
    zh: '上边框宽度',
    value: '<border-width> | inherit',
    initial: 'medium',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: "绝对长度；border-style 为 'none' 或 'hidden' 时为 0",
    css2Url: `${BOX}#propdef-border-top-width`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-right-width': {
    zh: '右边框宽度',
    value: '<border-width> | inherit',
    initial: 'medium',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: "绝对长度；border-style 为 'none' 或 'hidden' 时为 0",
    css2Url: `${BOX}#propdef-border-right-width`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-bottom-width': {
    zh: '下边框宽度',
    value: '<border-width> | inherit',
    initial: 'medium',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: "绝对长度；border-style 为 'none' 或 'hidden' 时为 0",
    css2Url: `${BOX}#propdef-border-bottom-width`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-left-width': {
    zh: '左边框宽度',
    value: '<border-width> | inherit',
    initial: 'medium',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: "绝对长度；border-style 为 'none' 或 'hidden' 时为 0",
    css2Url: `${BOX}#propdef-border-left-width`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-width': {
    zh: '边框宽度（简写）',
    value: '<border-width>{1,4} | inherit',
    initial: '见各子属性',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '见各子属性',
    css2Url: `${BOX}#propdef-border-width`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },

  // ── border-color ──
  'border-top-color': {
    zh: '上边框颜色',
    value: '<color> | transparent | inherit',
    initial: "color 属性的值",
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: "取自 color 属性时为 color 的计算值；否则为指定值",
    css2Url: `${BOX}#propdef-border-top-color`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-right-color': {
    zh: '右边框颜色',
    value: '<color> | transparent | inherit',
    initial: "color 属性的值",
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: "取自 color 属性时为 color 的计算值；否则为指定值",
    css2Url: `${BOX}#propdef-border-right-color`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-bottom-color': {
    zh: '下边框颜色',
    value: '<color> | transparent | inherit',
    initial: "color 属性的值",
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: "取自 color 属性时为 color 的计算值；否则为指定值",
    css2Url: `${BOX}#propdef-border-bottom-color`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-left-color': {
    zh: '左边框颜色',
    value: '<color> | transparent | inherit',
    initial: "color 属性的值",
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: "取自 color 属性时为 color 的计算值；否则为指定值",
    css2Url: `${BOX}#propdef-border-left-color`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-color': {
    zh: '边框颜色（简写）',
    value: '[ <color> | transparent ]{1,4} | inherit',
    initial: '见各子属性',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '见各子属性',
    css2Url: `${BOX}#propdef-border-color`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },

  // ── border-style ──
  'border-top-style': {
    zh: '上边框样式',
    value: '<border-style> | inherit',
    initial: 'none',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '指定值',
    css2Url: `${BOX}#propdef-border-top-style`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-right-style': {
    zh: '右边框样式',
    value: '<border-style> | inherit',
    initial: 'none',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '指定值',
    css2Url: `${BOX}#propdef-border-right-style`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-bottom-style': {
    zh: '下边框样式',
    value: '<border-style> | inherit',
    initial: 'none',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '指定值',
    css2Url: `${BOX}#propdef-border-bottom-style`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-left-style': {
    zh: '左边框样式',
    value: '<border-style> | inherit',
    initial: 'none',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '指定值',
    css2Url: `${BOX}#propdef-border-left-style`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-style': {
    zh: '边框样式（简写）',
    value: '<border-style>{1,4} | inherit',
    initial: '见各子属性',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '见各子属性',
    css2Url: `${BOX}#propdef-border-style`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },

  // ── border shorthand ──
  'border-top': {
    zh: '上边框（简写）',
    value: '<border-width> || <border-style> || <color> | inherit',
    initial: '见各子属性',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '见各子属性',
    css2Url: `${BOX}#propdef-border-top`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-right': {
    zh: '右边框（简写）',
    value: '<border-width> || <border-style> || <color> | inherit',
    initial: '见各子属性',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '见各子属性',
    css2Url: `${BOX}#propdef-border-right`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-bottom': {
    zh: '下边框（简写）',
    value: '<border-width> || <border-style> || <color> | inherit',
    initial: '见各子属性',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '见各子属性',
    css2Url: `${BOX}#propdef-border-bottom`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border-left': {
    zh: '左边框（简写）',
    value: '<border-width> || <border-style> || <color> | inherit',
    initial: '见各子属性',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '见各子属性',
    css2Url: `${BOX}#propdef-border-left`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },
  'border': {
    zh: '边框（简写）',
    value: '<border-width> || <border-style> || <color> | inherit',
    initial: '见各子属性',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '见各子属性',
    css2Url: `${BOX}#propdef-border`,
    css3Url: BG3,
    sectionRef: 'box-model#borders',
  },

  // ── margin-trim (CSS Box 4) ──
  'margin-trim': {
    zh: '外边距裁剪',
    value: 'none | [ block || inline ] | [ block-start || inline-start || block-end || inline-end ]',
    initial: 'none',
    appliesTo: 'block containers、multi-column containers、flex containers、grid containers',
    inherited: false,
    percentages: null,
    computedValue: '零到四个关键字的集合,表示裁剪哪几侧',
    css2Url: 'https://www.w3.org/TR/css-box-4/#propdef-margin-trim',
    css3Url: 'https://www.w3.org/TR/css-box-4/#propdef-margin-trim',
    sectionRef: 'box-model#margins',
  },

  // ── logical properties (CSS Logical 1) ──
  'margin-block': {
    zh: '块方向外边距',
    value: "<'margin-top'>{1,2}",
    initial: '0',
    appliesTo: APPLIES_MARGIN,
    inherited: false,
    percentages: '相对于包含块的逻辑宽度(inline-size)',
    computedValue: '各分量的计算值',
    css2Url: '',
    css3Url: LOGICAL,
    sectionRef: 'box-model#logical-properties',
  },
  'margin-inline': {
    zh: '行内方向外边距',
    value: "<'margin-top'>{1,2}",
    initial: '0',
    appliesTo: APPLIES_MARGIN,
    inherited: false,
    percentages: '相对于包含块的逻辑宽度(inline-size)',
    computedValue: '各分量的计算值',
    css2Url: '',
    css3Url: LOGICAL,
    sectionRef: 'box-model#logical-properties',
  },
  'padding-block': {
    zh: '块方向内边距',
    value: "<'padding-top'>{1,2}",
    initial: '0',
    appliesTo: APPLIES_PADDING,
    inherited: false,
    percentages: '相对于包含块的逻辑宽度(inline-size)',
    computedValue: '各分量的计算值',
    css2Url: '',
    css3Url: LOGICAL,
    sectionRef: 'box-model#logical-properties',
  },
  'padding-inline': {
    zh: '行内方向内边距',
    value: "<'padding-top'>{1,2}",
    initial: '0',
    appliesTo: APPLIES_PADDING,
    inherited: false,
    percentages: '相对于包含块的逻辑宽度(inline-size)',
    computedValue: '各分量的计算值',
    css2Url: '',
    css3Url: LOGICAL,
    sectionRef: 'box-model#logical-properties',
  },
  'border-block': {
    zh: '块方向边框',
    value: "<'border-top-width'> || <'border-top-style'> || <color>",
    initial: '见各子属性',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '见各子属性',
    css2Url: '',
    css3Url: LOGICAL,
    sectionRef: 'box-model#logical-properties',
  },
  'border-inline': {
    zh: '行内方向边框',
    value: "<'border-top-width'> || <'border-top-style'> || <color>",
    initial: '见各子属性',
    appliesTo: '所有元素',
    inherited: false,
    percentages: null,
    computedValue: '见各子属性',
    css2Url: '',
    css3Url: LOGICAL,
    sectionRef: 'box-model#logical-properties',
  },
  'inline-size': {
    zh: '行内方向尺寸',
    value: "<'width'>",
    initial: 'auto',
    appliesTo: '与 width 相同',
    inherited: false,
    percentages: '相对于包含块的 inline-size',
    computedValue: '与 width 相同',
    css2Url: '',
    css3Url: LOGICAL,
    sectionRef: 'box-model#logical-properties',
  },
  'block-size': {
    zh: '块方向尺寸',
    value: "<'height'>",
    initial: 'auto',
    appliesTo: '与 height 相同',
    inherited: false,
    percentages: '相对于包含块的 block-size',
    computedValue: '与 height 相同',
    css2Url: '',
    css3Url: LOGICAL,
    sectionRef: 'box-model#logical-properties',
  },
  'inset-block': {
    zh: '块方向偏移',
    value: "<'top'>{1,2}",
    initial: 'auto',
    appliesTo: '定位元素',
    inherited: false,
    percentages: '相对于包含块的 block-size',
    computedValue: '各分量的计算值',
    css2Url: '',
    css3Url: LOGICAL,
    sectionRef: 'box-model#logical-properties',
  },
  'inset-inline': {
    zh: '行内方向偏移',
    value: "<'top'>{1,2}",
    initial: 'auto',
    appliesTo: '定位元素',
    inherited: false,
    percentages: '相对于包含块的 inline-size',
    computedValue: '各分量的计算值',
    css2Url: '',
    css3Url: LOGICAL,
    sectionRef: 'box-model#logical-properties',
  },
};

// ============================================================
// 术语表
// ============================================================

export const glossaryTerms: Record<string, GlossaryEntry> = {
  'content area': {
    zh: '内容区域',
    description: '盒模型最内层的矩形区域,包含元素的实际内容(文本、图片等),大小由 width/height 属性控制。',
    sectionRef: 'box-model#box-model',
  },
  'padding area': {
    zh: '内边距区域',
    description: '内容区域和边框之间的空间,由 padding 属性控制。背景会延伸到内边距区域。',
    sectionRef: 'box-model#paddings',
  },
  'border area': {
    zh: '边框区域',
    description: '内边距和外边距之间的区域,由 border 属性控制宽度、样式和颜色。',
    sectionRef: 'box-model#borders',
  },
  'margin area': {
    zh: '外边距区域',
    description: '盒子最外层的透明区域,用于创建元素之间的间距。margin 可以为负值。',
    sectionRef: 'box-model#margins',
  },
  'margin collapsing': {
    zh: '外边距折叠',
    description: '垂直方向上相邻的 margin 会合并为一个(取较大值),而非叠加。这是 block layout 的特殊行为。',
    sectionRef: 'box-model#margins',
  },
  'content edge': {
    zh: '内容边缘',
    description: '内容区域的边界,即 content area 的外边缘。',
    sectionRef: 'box-model#box-model',
  },
  'padding edge': {
    zh: '内边距边缘',
    description: '内边距区域的外边界,即 padding area 的外边缘。也称为内边距框的边。',
    sectionRef: 'box-model#paddings',
  },
  'border edge': {
    zh: '边框边缘',
    description: '边框区域的外边界,即 border area 的外边缘。',
    sectionRef: 'box-model#borders',
  },
  'margin edge': {
    zh: '外边距边缘',
    description: '外边距区域的外边界,即 margin area 的外边缘,也是盒子占用空间的最外层。',
    sectionRef: 'box-model#margins',
  },
  'inner edge': {
    zh: '内边缘',
    description: '内容区域的边界,等同于 content edge。',
    sectionRef: 'box-model#box-model',
  },
  'outer edge': {
    zh: '外边缘',
    description: '外边距区域的边界,等同于 margin edge,是盒子在布局中占据空间的最外层。',
    sectionRef: 'box-model#margins',
  },
  'content box': {
    zh: '内容框',
    description: '由 content edge 围成的矩形区域,包含元素的实际内容。box-sizing: content-box 的参考框。',
    sectionRef: 'box-model#box-model',
  },
  'padding box': {
    zh: '内边距框',
    description: '由 padding edge 围成的矩形区域,包含内容和内边距。background-origin 的默认参考框。',
    sectionRef: 'box-model#paddings',
  },
  'border box': {
    zh: '边框框',
    description: '由 border edge 围成的矩形区域。box-sizing: border-box 的参考框,也是 background-clip 的默认裁剪区域。',
    sectionRef: 'box-model#borders',
  },
  'margin box': {
    zh: '外边距框',
    description: '由 margin edge 围成的矩形区域。盒子在流式布局中实际占据的完整空间。',
    sectionRef: 'box-model#margins',
  },
  'content-box': {
    zh: '内容框(值)',
    description: 'box-sizing 属性的值之一。宽高只包含内容区域,padding 和 border 额外增加尺寸。CSS2 的默认行为。',
    sectionRef: 'box-model#box-model',
  },
  'border-box': {
    zh: '边框框(值)',
    description: 'box-sizing 属性的值之一。宽高包含内容、内边距和边框,让尺寸计算更直观。',
    sectionRef: 'box-model#box-model',
  },
  'margin properties': {
    zh: '外边距属性',
    description: 'margin-top、margin-right、margin-bottom、margin-left 及简写 margin。控制盒子外部的空间。',
    sectionRef: 'box-model#margins',
  },
  'padding properties': {
    zh: '内边距属性',
    description: 'padding-top、padding-right、padding-bottom、padding-left 及简写 padding。控制内容与边框之间的空间。',
    sectionRef: 'box-model#paddings',
  },
  'border properties': {
    zh: '边框属性',
    description: 'border-width、border-style、border-color 及相关简写属性。控制盒子边框的外观。',
    sectionRef: 'box-model#borders',
  },
  'box-sizing': {
    zh: '盒尺寸计算模式',
    description: '决定 width/height 是仅包含 content area(content-box)还是包含 padding 和 border(border-box)。影响盒子的实际渲染尺寸。',
    sectionRef: 'box-model#box-model',
    specUrl: 'https://www.w3.org/TR/css-sizing-3/#box-sizing',
  },
  'logical properties': {
    zh: '逻辑属性',
    description: '基于书写模式(writing mode)的 flow-relative 方向属性,如 margin-block-start、padding-inline-end。与物理属性控制同一组 margin/padding/border。',
    sectionRef: 'box-model#logical-properties',
    specUrl: LOGICAL,
  },
  'block dimension': {
    zh: '块维度',
    description: '与块流方向平行的维度。在水平书写模式下对应垂直方向(top/bottom),在垂直书写模式下对应水平方向。段落沿此方向堆叠。',
    sectionRef: 'box-model#logical-properties',
    specUrl: LOGICAL,
  },
  'inline dimension': {
    zh: '行内维度',
    description: '与行内流方向平行的维度。在水平书写模式下对应水平方向(left/right),在垂直书写模式下对应垂直方向。文本沿此方向书写。',
    sectionRef: 'box-model#logical-properties',
    specUrl: LOGICAL,
  },
  'flow-relative': {
    zh: '流相对',
    description: '相对于文本流方向而非固定物理方向的定位方式。逻辑属性基于 flow-relative 坐标系统,会根据 writing-mode 和 direction 自动映射到物理方向。',
    sectionRef: 'box-model#logical-properties',
    specUrl: LOGICAL,
  },
  'margin-trim': {
    zh: '外边距裁剪',
    description: '容器属性,允许裁剪子元素靠近容器边缘处的 margin。适用于 block containers、flex containers、grid containers。CSS Box Model Level 4 新增。',
    sectionRef: 'box-model#margins',
    specUrl: 'https://www.w3.org/TR/css-box-4/#margin-trim',
  },
  'box-decoration-break': {
    zh: '盒装饰断裂',
    description: '控制盒子分片(如跨行、跨页)时 padding、border、background 等装饰如何处理。值为 slice(默认,切片延续)或 clone(每个片段独立装饰)。',
    sectionRef: 'box-model#box-model',
    specUrl: 'https://www.w3.org/TR/css-break-4/#propdef-box-decoration-break',
  },
  'fragmentation': {
    zh: '分片',
    description: '盒子被断开(如跨行、跨列或跨页)成多个 box fragment 的过程。分片时 content/padding/border/margin 各区域均随之分片。',
    sectionRef: 'box-model#box-model',
    specUrl: 'https://www.w3.org/TR/css-break-3/#fragmentation-model',
  },
  'adjoining margins': {
    zh: '相邻外边距',
    description: '两个或多个满足折叠条件的 margin。要求:均属于同一 BFC 中的 in-flow block-level boxes,之间无 line box、clearance、padding 或 border 分隔。',
    sectionRef: 'box-model#margins',
    css2Url: 'https://www.w3.org/TR/CSS22/box.html#collapsing-margins',
  },
  'collapsed margin': {
    zh: '折叠后的外边距',
    description: '相邻 margin 合并后的结果。正值取最大值;有负值时,从正值最大值中扣除负值绝对值的最大值;全为负值时取绝对值最大的负值。',
    sectionRef: 'box-model#margins',
    css2Url: 'https://www.w3.org/TR/CSS22/box.html#collapsing-margins',
  },
  '<visual-box>': {
    zh: '视觉框类型',
    description: 'box-edge 关键字子集:content-box | padding-box | border-box。用于 background-clip 等仅涉及可视区域的属性。',
    sectionRef: 'box-model#box-model',
    specUrl: 'https://www.w3.org/TR/css-box-3/#typedef-visual-box',
  },
  '<layout-box>': {
    zh: '布局框类型',
    description: '<visual-box> | margin-box。用于涉及布局计算(包含 margin)的属性。',
    sectionRef: 'box-model#box-model',
    specUrl: 'https://www.w3.org/TR/css-box-3/#typedef-layout-box',
  },
  'border-style values': {
    zh: '边框样式值',
    description: '共 10 种:none(无)、hidden(隐藏)、dotted(点线)、dashed(虚线)、solid(实线)、double(双线)、groove(凹槽)、ridge(凸脊)、inset(内嵌)、outset(外凸)。',
    sectionRef: 'box-model#borders',
    css2Url: 'https://www.w3.org/TR/CSS22/box.html#border-style-properties',
  },
};

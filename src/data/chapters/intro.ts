import type { Section, TutorialBlock } from '../modules';
import type { GlossaryEntry } from '../glossary';

export const sections: Section[] = [
  {
    id: 'css-overview',
    number: '1',
    title: { zh: 'CSS 是什么', en: 'What is CSS?' },
    specId: 'html-tutorial',
    summary: {
      zh: 'CSS（Cascading Style Sheets，层叠样式表）是一种样式语言，用于描述结构化文档（如 HTML、XML）的视觉呈现。它的核心设计理念是将文档的内容结构与视觉表现分离——HTML 负责「说什么」，CSS 负责「怎么看起来」。CSS 通过选择器定位元素，通过属性-值对（如 color: red）声明样式规则，并通过层叠机制解决多个来源的样式冲突。样式表有三个来源：作者样式表（网站开发者编写）、用户样式表（浏览网页的用户提供）、用户代理样式表（浏览器内置的默认样式）。CSS 可以内嵌在 HTML 的 <style> 标签中，也可以通过 <link> 引用外部样式表文件。',
      en: 'CSS (Cascading Style Sheets) is a style language used to describe the visual presentation of structured documents (such as HTML and XML). Its core design principle is to separate document content structure from visual presentation—HTML handles "what to say," while CSS handles "how it looks." CSS uses selectors to target elements, declares style rules through property-value pairs (like color: red), and resolves conflicts from multiple sources through the cascade mechanism. Style sheets come from three sources: author style sheets (written by website developers), user style sheets (provided by people browsing the web), and user agent style sheets (browser default styles). CSS can be embedded in HTML via <style> tags or referenced from external style sheet files via <link>.',
    },
    keyPoints: [
      'CSS 将文档结构与视觉呈现分离，让同一份 HTML 可以用不同样式表呈现不同外观',
      '样式规则由「选择器 + 声明块」组成，例如 h1 { color: red; font-size: 2em; }',
      '三种样式表来源：作者（网站开发者）、用户（浏览网页的人）、用户代理（浏览器默认样式）',
      'CSS 可以应用于任何结构化文档格式，不仅限于 HTML——XML 文档同样可以用 CSS 渲染',
      '外部样式表通过 <link rel="stylesheet" href="style.css"> 引入，实现样式复用和集中维护',
      'CSS 属性有继承性——某些属性（如 color、font-family）会自动从父元素传递给子元素',
    ],
    tutorial: [
      { type: 'heading', text: 'CSS 的核心使命：内容与表现分离' },
      { type: 'paragraph', text: 'CSS 的诞生源于一个简单而深刻的理念：**内容**（说什么）应该与**表现**（怎么看）分离。HTML 负责定义文档的结构和语义——标题、段落、列表、链接，而 CSS 负责这些元素的视觉呈现——颜色、字体、间距、布局。这种分离带来了巨大的好处：同一份 HTML 文档可以通过不同的样式表呈现完全不同的外观，样式可以跨页面复用，维护更加集中高效。' },
      { type: 'example', title: '同一份 HTML，两种样式', code: '<h1>欢迎来到我的网站</h1>\n<p>这是一段介绍文字。</p>', lang: 'html', explanation: '配合样式表 A（蓝色标题 + 大字号）或样式表 B（红色标题 + 小字号），这段 HTML 会呈现截然不同的视觉效果。' },
      { type: 'code', code: '/* 基础 CSS 规则的解剖 */\nh1 {           /* 选择器：定位文档中所有 <h1> 元素 */\n  color: red;  /* 声明：属性 color 被赋值为 red */\n  font-size: 2em;\n}              /* 声明块：大括号内所有声明的集合 */', lang: 'css', caption: 'CSS 规则 = 选择器 + 声明块' },
      { type: 'heading', text: 'CSS 规则的语法结构' },
      { type: 'paragraph', text: 'CSS 规则由两部分组成：**选择器**（selector）定位你要样式化的元素，**声明块**（declaration block）包含一组声明。每个**声明**（declaration）是一对**属性**（property）和**值**（value），用冒号分隔，分号结尾。属性是 CSS 定义的渲染参数（如 `color`、`margin`），值是你赋予它的数据（如 `red`、`10px`）。' },
      { type: 'code', code: 'p {                      /* ← 选择器 */\n  color: blue;           /* ← 属性: 值; */\n  margin: 1em 0;         /* ← 属性: 值; */\n  font-family: Arial;    /* ← 属性: 值; */\n}                        /* ← 声明块 */', lang: 'css', caption: '完整的规则集（rule set）结构' },
      { type: 'heading', text: '样式表的三种来源' },
      { type: 'list', items: [
        '**作者样式表**（author style sheet）：网站开发者编写的样式，通过 `<link>` 或 `<style>` 引入',
        '**用户样式表**（user style sheet）：浏览网页的用户提供的个人样式，通常用于无障碍需求（如强制高对比度）',
        '**用户代理样式表**（user agent style sheet）：浏览器内置的默认样式，确保未样式化的 HTML 也有基本可读性'
      ] },
      { type: 'paragraph', text: '这三种来源的样式会通过 CSS 的**层叠机制**（cascade）合并和解决冲突。通常作者样式优先级最高，但用户可以用 `!important` 覆盖作者样式（第 4 章会详细讲解层叠）。' },
      { type: 'heading', text: '引入 CSS 的方式' },
      { type: 'code', code: '<!-- 方式 1: 外部样式表（推荐） -->\n<link rel="stylesheet" href="style.css">\n\n<!-- 方式 2: 内部样式表 -->\n<style>\n  h1 { color: navy; }\n</style>\n\n<!-- 方式 3: 内联样式（尽量避免） -->\n<p style="color: red;">直接在元素上声明样式</p>', lang: 'html' },
      { type: 'tip', text: '外部样式表是最佳实践：样式可以跨页面复用，浏览器可以缓存文件，维护更集中。内联样式虽然方便但会破坏内容与表现分离，且优先级极高难以覆盖。' },
      { type: 'heading', text: 'CSS 的继承特性' },
      { type: 'example', title: '颜色从父元素继承到子元素', code: '<div style="color: green;">\n  <p>这段文字是绿色的</p>\n  <p>这段也是绿色的</p>\n</div>', lang: 'html', explanation: '`color` 属性是可继承属性，子元素自动获得父元素的颜色值，无需重复声明。' },
      { type: 'paragraph', text: '并非所有属性都会继承——通常只有与文本相关的属性（`color`、`font-family`、`line-height` 等）会继承，而盒子模型属性（`margin`、`border`、`width` 等）不会。继承的设计目标是减少重复：在 `<body>` 上声明字体，整个页面都会应用，除非子元素显式覆盖。' },
      { type: 'tip', text: '继承是 CSS 中最强大的省力机制之一。想让整个页面用同一字体？只需在 `body` 上声明 `font-family` 一次即可。' },
      { type: 'warning', text: 'CSS 只能应用于已经解析好的文档树——如果 HTML 语法错误导致浏览器解析失败，CSS 无法修复。确保 HTML 合法是 CSS 正常工作的前提。' },
    ] as TutorialBlock[],
  },
  {
    id: 'design-principles',
    number: '2',
    title: { zh: '设计原则', en: 'Design Principles' },
    specId: 'design-principles',
    summary: {
      zh: 'CSS 的设计遵循一套核心原则，这些原则确保了 CSS 能够持续演进而不破坏现有内容。最重要的是「前向兼容」——浏览器遇到不认识的 CSS 语法时会跳过而非报错，这让新特性可以安全添加而不影响旧浏览器。「层叠机制」让来自多个来源的样式规则可以共存并有序解决冲突。「继承机制」减少重复声明，让样式自然传播。「用户控制」原则确保用户可以覆盖作者样式以满足无障碍需求（如强制高对比度）。CSS 还强调平台独立性、网络性能、简洁性和灵活性——既要足够简单让人类阅读和编写，又要足够强大支持丰富的视觉表现。',
      en: 'CSS design follows a set of core principles that ensure CSS can continue to evolve without breaking existing content. Most important is "forward compatibility"—browsers skip unrecognized CSS syntax rather than throwing errors, allowing new features to be safely added without affecting older browsers. The "cascade mechanism" allows style rules from multiple sources to coexist and resolve conflicts in an orderly manner. The "inheritance mechanism" reduces repetitive declarations by allowing styles to propagate naturally. The "user control" principle ensures users can override author styles to meet accessibility needs (such as enforcing high contrast). CSS also emphasizes platform independence, network performance, simplicity, and flexibility—being simple enough for humans to read and write, yet powerful enough to support rich visual presentation.',
    },
    keyPoints: [
      '前向兼容：CSS2 浏览器能理解 CSS1，CSS1 浏览器会忽略 CSS2 的新特性而不会崩溃',
      '后向兼容：旧浏览器忽略不认识的属性/值，新浏览器仍支持旧语法（除非明确废弃）',
      '层叠机制：多个来源（作者/用户/UA）的样式规则按优先级、特异性、顺序解决冲突',
      '继承机制：某些属性（color、font-family 等）自动从父元素传给子元素，减少重复',
      '用户控制：用户可以提供个人样式表，并用 !important 覆盖作者样式（无障碍需求）',
      '平台独立性：同一份样式表可应用于不同设备（屏幕、打印、语音），通过 @media 适配',
      '简洁性：CSS 语法人类可读可写，属性尽量独立，通常只有一种方式实现某个效果',
      '网络性能：相比图片/音频，样式表体积小、可复用、减少网络连接',
    ],
    tutorial: [
      { type: 'heading', text: '前向兼容：CSS 的生存策略' },
      { type: 'paragraph', text: 'CSS 最重要的设计原则是**前向兼容**（forward compatibility）——新特性的加入不会破坏旧浏览器。当浏览器遇到不认识的 CSS 语法（未知属性、未知值、未知 at-rule）时，它会**跳过这条规则**而不是报错崩溃。这让 CSS 可以持续演进：你可以放心使用新特性，旧浏览器会优雅降级，新浏览器会应用增强效果。' },
      { type: 'example', title: '浏览器优雅跳过未知属性', code: '.box {\n  color: blue;               /* 所有浏览器都支持 */\n  display: grid;             /* 旧浏览器跳过这行 */\n  gap: 1em;                  /* 旧浏览器跳过这行 */\n  background: oklch(70% 0.2 150deg); /* 旧浏览器跳过 */\n}', lang: 'css', explanation: '不支持 Grid 或 oklch() 的浏览器会忽略这些声明，但 `color: blue` 仍然生效。整个样式表不会因为一行新语法而失效。' },
      { type: 'code', code: '/* 使用新特性 + 降级方案 */\n.button {\n  background: linear-gradient(blue, navy); /* 旧浏览器降级到纯色 */\n  background: navy; /* 降级方案写在前面 */\n  background: linear-gradient(blue, navy); /* 新特性写在后面 */\n}', lang: 'css', caption: '层叠机制配合前向兼容实现渐进增强' },
      { type: 'heading', text: '层叠机制：解决冲突的规则' },
      { type: 'paragraph', text: '当多个样式规则应用于同一元素时，CSS 通过**层叠**（cascade）机制决定哪条规则胜出。层叠按三个维度排序：**来源和重要性**（作者 vs 用户 vs UA，是否有 `!important`）、**选择器特异性**（ID > class > 标签）、**声明顺序**（后声明覆盖先声明）。第 4 章会详细讲解层叠算法，这里只需理解：层叠让来自多个来源的样式可以共存并有序解决冲突。' },
      { type: 'heading', text: '继承机制：减少重复' },
      { type: 'paragraph', text: '**继承**（inheritance）让子元素自动获得父元素的某些属性值，无需重复声明。通常与文本相关的属性（`color`、`font-family`、`line-height`）会继承，而盒子模型属性（`margin`、`border`、`width`）不会。继承的设计目标是减少样式表体积：你不需要为每个段落单独设置字体，只需在 `<body>` 上声明一次。' },
      { type: 'heading', text: '用户控制与无障碍' },
      { type: 'paragraph', text: 'CSS 设计时充分考虑了用户的自主权。用户可以提供个人样式表（user style sheet）覆盖网站的样式——这对有视觉障碍的用户至关重要（如强制高对比度、放大字号）。用户可以在自己的样式表中使用 `!important` 让声明拥有最高优先级，即使作者样式也有 `!important`，用户的仍然胜出。' },
      { type: 'warning', text: '作为网站开发者，不要滥用 `!important`——它会让用户样式表难以覆盖你的样式，损害无障碍体验。只在绝对必要时使用。' },
      { type: 'heading', text: '平台独立性' },
      { type: 'paragraph', text: 'CSS 设计为**平台无关**——同一份样式表可以应用于屏幕、打印、语音合成器、盲文设备。通过 `@media` 规则，你可以为不同媒体类型定义不同样式，但核心样式可以共享。' },
      { type: 'code', code: '/* 屏幕和打印共享的基础样式 */\nbody { font-family: Arial; }\n\n/* 打印时隐藏导航栏 */\n@media print {\n  nav { display: none; }\n  body { font-size: 12pt; }\n}', lang: 'css', caption: '通过 @media 为不同媒体定制样式' },
      { type: 'tip', text: 'CSS 设计为人类可读可写——你不需要工具就能理解和修改样式表。相比之下，二进制格式（如图片）必须用专门工具才能编辑。' },
      { type: 'heading', text: '网络性能优势' },
      { type: 'paragraph', text: 'CSS 样式表通常只有几 KB 到几十 KB，远小于图片或视频。外部样式表可以被浏览器缓存，多个页面共享同一份文件，大幅减少网络传输。相比用图片实现按钮、渐变、阴影，用 CSS 实现体积更小、加载更快、可缩放、可修改。' },
      { type: 'list', items: [
        '前向兼容让 CSS 可以持续演进而不破坏现有内容',
        '层叠机制让多个来源的样式有序共存',
        '继承机制减少重复声明',
        '用户控制确保无障碍用户可以覆盖样式',
        '平台独立性让样式跨设备复用',
        '简洁的文本格式带来性能和可维护性优势'
      ] },
      { type: 'tip', text: '这些设计原则不是孤立的——它们相互配合，共同塑造了 CSS 的健壮性和灵活性。理解这些原则能帮助你更好地使用 CSS。' },
    ] as TutorialBlock[],
  },
  {
    id: 'processing-model',
    number: '3',
    title: { zh: '处理模型', en: 'Processing Model' },
    specId: 'processing-model',
    summary: {
      zh: 'CSS 的处理模型描述了浏览器如何从源文档到最终渲染的完整流程。第一步，解析源文档（HTML/XML）生成文档树（document tree），树中的每个节点是一个元素。第二步，根据目标媒体类型（屏幕/打印/语音等）获取所有适用的样式表。第三步，为文档树中的每个元素的每个属性计算值（通过层叠、继承、初始值确定）。第四步，应用格式化算法生成格式化结构（formatting structure）——它类似文档树但可能不同（如 display: none 的元素不生成盒子，列表元素会生成额外的项目符号）。第五步，将格式化结构渲染到 Canvas（渲染表面）。Canvas 是抽象的无限平面，实际渲染发生在有限区域内（屏幕视口、打印页面等）。',
      en: 'The CSS processing model describes the complete flow from source document to final rendering. First, parse the source document (HTML/XML) to generate a document tree, where each node is an element. Second, retrieve all applicable style sheets based on the target media type (screen/print/speech, etc.). Third, compute values for each property of each element in the document tree (determined through cascading, inheritance, and initial values). Fourth, apply formatting algorithms to generate the formatting structure—similar to but potentially different from the document tree (elements with display: none generate no boxes, list elements generate additional markers). Fifth, render the formatting structure to the Canvas (rendering surface). The Canvas is an abstract infinite plane, with actual rendering occurring in a finite area (screen viewport, print page, etc.).',
    },
    keyPoints: [
      '处理流程：解析文档 → 获取样式表 → 计算属性值 → 生成格式化结构 → 渲染到 Canvas',
      '文档树（document tree）：源文档解析后的元素层次结构，每个元素是一个节点',
      '格式化结构（formatting structure）：用于渲染的结构，可能与文档树不同（display: none 不生成盒子，::before 生成额外内容）',
      'Canvas（画布）：渲染目标表面，每个维度无限大，但实际渲染在有限区域（视口/页面）',
      '媒体类型决定格式化算法：屏幕用视觉格式化模型（盒子、布局），语音用听觉模型',
      '属性值计算依赖层叠、继承、初始值三个机制，最终每个元素/属性都有确定的值',
      'CSS 不修改文档树——生成内容（::before）不会反馈到文档解析器重新解析',
    ],
    tutorial: [
      { type: 'heading', text: '从 HTML 到像素：5 步流程' },
      { type: 'paragraph', text: 'CSS 规范定义了一个清晰的处理模型，描述浏览器如何从源文档（HTML）到最终的像素渲染。理解这个流程能帮助你理解 CSS 的行为边界——什么可以做，什么不能做。' },
      { type: 'list', ordered: true, items: [
        '**解析文档**：HTML/XML 解析器将源文档转换为文档树（document tree）',
        '**获取样式表**：收集所有适用于当前媒体类型的样式表（作者 + 用户 + UA）',
        '**计算属性值**：对每个元素的每个属性，通过层叠、继承、初始值确定最终值',
        '**生成格式化结构**：应用格式化算法生成格式化结构（可能与文档树不同）',
        '**渲染到 Canvas**：将格式化结构绘制到 Canvas（抽象的无限渲染表面）'
      ] },
      { type: 'heading', text: '第一步：解析文档树' },
      { type: 'paragraph', text: '浏览器首先解析 HTML/XML 源文档，生成**文档树**（document tree）——一个元素的层次结构。文档树中的每个节点是一个元素（如 `<p>`、`<div>`），元素之间有父子关系。根元素（HTML 中是 `<html>`）位于树的顶端，没有父元素。' },
      { type: 'code', code: '<!-- HTML 源文档 -->\n<html>\n  <body>\n    <h1>标题</h1>\n    <p>段落</p>\n  </body>\n</html>\n\n<!-- 对应的文档树结构 -->\nhtml\n└─ body\n   ├─ h1\n   │  └─ [文本节点: "标题"]\n   └─ p\n      └─ [文本节点: "段落"]', lang: 'html', caption: 'HTML 解析为文档树' },
      { type: 'heading', text: '第二步：获取样式表' },
      { type: 'paragraph', text: '浏览器收集所有适用于当前**媒体类型**的样式表。媒体类型包括 `screen`（屏幕）、`print`（打印）、`speech`（语音合成）等。样式表来自三个来源：作者样式表（你写的）、用户样式表（用户提供）、用户代理样式表（浏览器默认样式）。' },
      { type: 'heading', text: '第三步：计算属性值' },
      { type: 'paragraph', text: '对文档树中的每个元素的每个 CSS 属性，浏览器必须确定一个**计算值**（computed value）。这个过程依赖三个机制：**层叠**（cascade）解决多个声明的冲突，**继承**（inheritance）让子元素获得父元素的值，**初始值**（initial value）作为最终降级。最终每个元素的每个属性都有确定的值。' },
      { type: 'heading', text: '第四步：生成格式化结构' },
      { type: 'paragraph', text: '有了计算后的属性值，浏览器应用**格式化算法**生成**格式化结构**（formatting structure）。格式化结构类似文档树，但可能不同——某些元素不生成盒子（如 `display: none`），某些元素生成多个盒子（如 `display: list-item` 生成主盒子 + 项目符号盒子），伪元素（如 `::before`）生成额外盒子。' },
      { type: 'example', title: 'display: none 不生成盒子', code: '<div style="display: none;">\n  <p>这段内容不会被渲染</p>\n</div>', lang: 'html', explanation: '`display: none` 的元素及其子元素都不会进入格式化结构，完全不参与渲染。' },
      { type: 'warning', text: 'CSS **永远不会修改文档树**——生成内容（`::before`、`::after`）只存在于格式化结构中，不会反馈到文档解析器。JavaScript 的 DOM API 也看不到伪元素。' },
      { type: 'heading', text: '第五步：渲染到 Canvas' },
      { type: 'paragraph', text: '最后，浏览器将格式化结构渲染到 **Canvas**（画布）。Canvas 是一个抽象的无限平面，在每个维度上都无限大。实际渲染发生在有限区域内——屏幕渲染在视口（viewport），打印渲染在页面。Canvas 的坐标系和尺寸取决于媒体类型：屏幕的 Canvas 通常以像素为单位，打印的 Canvas 以物理尺寸（如厘米）为单位。' },
      { type: 'tip', text: 'Canvas 的「无限大」是抽象概念——你可以定位元素到负坐标或极大坐标，但只有落在视口内的部分可见。' },
      { type: 'code', code: '/* 元素可以渲染在 Canvas 的任意位置 */\n.element {\n  position: absolute;\n  left: -1000px;  /* 在视口左侧 1000px，通常不可见 */\n  top: 50000px;   /* 在视口下方很远，需要滚动才能看到 */\n}', lang: 'css', caption: 'Canvas 无限大，但视口有限' },
      { type: 'list', items: [
        '文档树是源文档的语法结构，格式化结构是渲染的逻辑结构',
        'CSS 不修改文档树，只影响格式化结构和渲染',
        '媒体类型决定使用哪种格式化算法（视觉 vs 听觉）',
        'Canvas 是抽象的无限渲染表面，视口是其中的可见区域'
      ] },
      { type: 'tip', text: '这个 5 步流程是 CSS 规范的核心抽象——实际浏览器可能有优化（如增量渲染、GPU 加速），但逻辑流程相同。' },
    ] as TutorialBlock[],
  },
  {
    id: 'css-history',
    number: '4',
    title: { zh: 'CSS 的演进', en: 'CSS Evolution' },
    specId: 'css2.2-v-css2',
    summary: {
      zh: 'CSS 的演进经历了从单体规范到模块化的转变。CSS1（1996）定义了基础样式属性，CSS2（1998）大幅扩展了功能（定位、媒体类型、表格），但实现复杂导致浏览器差异大。CSS2.1（2011）是 CSS2 的勘误版，移除了未实现的特性，修正了与实际浏览器行为不一致的定义。CSS2.2 在 CSS2.1 基础上进一步修正错误。CSS3 不再是单一规范——它被拆分为独立的模块（Selectors、Values、Cascade、Flexbox、Grid 等），每个模块独立演进、独立发版。这种模块化设计让新特性可以更快标准化，不必等待整个规范完成。CSS Snapshot（如 CSS 2023、CSS 2024）是对某个时间点所有稳定 CSS 特性的快照汇总。规范成熟度分级：WD（工作草案）→ CR（候选推荐）→ PR（提议推荐）→ REC（正式推荐）。',
      en: 'CSS evolution has undergone a transformation from monolithic specifications to modularization. CSS1 (1996) defined basic style properties, CSS2 (1998) greatly expanded functionality (positioning, media types, tables), but implementation complexity led to significant browser differences. CSS2.1 (2011) is an errata version of CSS2 that removed unimplemented features and corrected definitions inconsistent with actual browser behavior. CSS2.2 further corrects errors building on CSS2.1. CSS3 is no longer a single specification—it has been split into independent modules (Selectors, Values, Cascade, Flexbox, Grid, etc.), each evolving and releasing independently. This modular design allows new features to be standardized faster without waiting for the entire specification to be complete. CSS Snapshots (like CSS 2023, CSS 2024) are snapshot summaries of all stable CSS features at a given point in time. Specification maturity levels: WD (Working Draft) → CR (Candidate Recommendation) → PR (Proposed Recommendation) → REC (Recommendation).',
    },
    keyPoints: [
      'CSS1 (1996) → CSS2 (1998) → CSS2.1 (2011) → CSS2.2 (2017)',
      'CSS2.1 移除了 CSS2 中未被浏览器实现的特性，修正与实际行为不符的定义',
      'CSS3 不是单一规范——它是一组独立模块的集合（Selectors Level 3、Cascade Level 4 等）',
      '模块化的好处：新特性可以独立演进和发布，不必等待整个「CSS3」完成',
      'CSS Snapshot（如 CSS 2023）：某个时间点所有稳定 CSS 特性的快照汇总',
      '规范成熟度：WD（工作草案）→ CR（候选推荐）→ PR（提议推荐）→ REC（正式推荐）',
      'CSS2.2 是 CSS2.1 的继任者，被后续 CSS3 模块引用为基础规范',
    ],
    tutorial: [
      { type: 'heading', text: '从 CSS1 到模块化' },
      { type: 'paragraph', text: 'CSS 的历史是一段从单体规范走向模块化的旅程。早期的 CSS1 和 CSS2 都是单一的大规范，但这种模式在 CSS2 之后遇到了瓶颈——规范太大、演进太慢、浏览器实现差异太大。CSS3 开始，W3C 采用了**模块化**策略：不再有单一的「CSS3」规范，而是拆分为数十个独立模块，各自演进、各自发版。' },
      { type: 'heading', text: 'CSS1 (1996)：起步' },
      { type: 'paragraph', text: 'CSS1 是 CSS 的第一个版本，定义了基础的样式属性：字体（`font-family`、`font-size`）、颜色（`color`、`background`）、文本（`text-align`、`line-height`）、盒子模型（`margin`、`padding`、`border`）。CSS1 的目标是提供最小可用的样式能力，让网页可以脱离 HTML 的呈现标签（如 `<font>`、`<center>`）。' },
      { type: 'heading', text: 'CSS2 (1998)：大跃进' },
      { type: 'paragraph', text: 'CSS2 大幅扩展了 CSS 的能力，新增了定位（`position: absolute/fixed`）、媒体类型（`@media`）、表格布局、`z-index`、生成内容（`::before`、`::after`）、计数器等特性。CSS2 的野心很大，但实现复杂度也很高——许多特性在浏览器中要么未实现，要么实现不一致，导致开发者困惑。' },
      { type: 'heading', text: 'CSS2.1 (2011)：务实修正' },
      { type: 'paragraph', text: 'CSS2.1 是对 CSS2 的勘误版（errata），目标是**与实际浏览器行为对齐**。CSS2.1 移除了未被广泛实现的特性（如某些听觉样式属性），修正了与浏览器行为不符的定义，澄清了模糊的措辞。CSS2.1 花了 13 年才从工作草案到正式推荐（1998-2011），是 CSS 历史上最重要的稳定基线。' },
      { type: 'heading', text: 'CSS3：不再是一个规范' },
      { type: 'paragraph', text: '从 CSS3 开始，W3C 不再发布单一的「CSS3 规范」，而是将 CSS 拆分为**独立模块**（modules）。每个模块有自己的版本号（Level）、自己的编辑、自己的发布节奏。这种模块化设计让新特性可以快速标准化，不必等待整个规范完成。' },
      { type: 'list', items: [
        '**Selectors Level 3**：选择器语法（`:nth-child()`、`[attr^="value"]` 等）',
        '**CSS Cascade Level 4**：层叠算法、`@layer` 规则',
        '**CSS Values and Units Level 4**：值类型和单位定义',
        '**CSS Flexbox Level 1**：弹性盒布局',
        '**CSS Grid Layout Level 1**：网格布局',
        '**CSS Color Level 4**：颜色模型（`oklch()`、`color-mix()` 等）'
      ] },
      { type: 'tip', text: '「CSS3」只是一个营销术语——实际应该说「Selectors Level 3」或「Flexbox」，而不是笼统地说「CSS3」。' },
      { type: 'heading', text: '规范成熟度等级' },
      { type: 'list', ordered: true, items: [
        '**WD（Working Draft，工作草案）**：规范的早期版本，随时可能大改',
        '**CR（Candidate Recommendation，候选推荐）**：规范相对稳定，**鼓励浏览器实现**',
        '**PR（Proposed Recommendation，提议推荐）**：即将成为正式标准，等待最终审查',
        '**REC（Recommendation，正式推荐）**：W3C 的正式标准'
      ] },
      { type: 'paragraph', text: 'CR 阶段是最重要的分水岭——进入 CR 意味着规范已经相对稳定，浏览器会开始认真实现。很多模块会在 CR 停留很长时间（如 Flexbox 在 CR 待了 5 年才到 REC），但 CR 期间的特性已经可以在生产环境使用。' },
      { type: 'tip', text: 'CR 不代表「还没做完」——它代表「规范稳定，等待浏览器实现和反馈」。CR 阶段的特性通常已经可以安全使用。' },
      { type: 'heading', text: 'CSS Snapshot：时间点快照' },
      { type: 'paragraph', text: '由于 CSS 被拆分为数十个模块，很难回答「现在 CSS 有哪些稳定特性」。W3C 每年发布 **CSS Snapshot**（如 CSS 2023、CSS 2024），汇总某个时间点所有已经稳定（CR 及以上）的 CSS 特性。Snapshot 不是规范本身，而是一份清单，指向各个模块的具体版本。' },
      { type: 'code', code: '// CSS Snapshot 2023 包含的部分模块：\n// - CSS2.2 (base)\n// - Selectors Level 3\n// - CSS Color Level 4\n// - CSS Flexbox Level 1\n// - CSS Grid Layout Level 1\n// - CSS Cascade Level 4\n// - CSS Custom Properties Level 1\n// ...', lang: 'javascript', caption: 'Snapshot 是稳定模块的清单' },
      { type: 'warning', text: '不要再问「CSS3 什么时候完成」——CSS3 永远不会「完成」，因为它不是单一规范。正确的问法是「某个模块什么时候到 CR」。' },
    ] as TutorialBlock[],
  },
  {
    id: 'reading-specs',
    number: '5',
    title: { zh: '如何阅读 CSS 规范', en: 'Reading CSS Specifications' },
    specId: 'reading',
    summary: {
      zh: 'CSS 规范是 CSS 的权威定义，但对初学者不够友好。规范的主要读者是浏览器开发者和 CSS 作者。学会阅读规范可以让你理解属性的精确行为、解决二手资料的模糊性、预判浏览器差异。规范通常包括：介绍章节（设计理念）、语法定义（如何解析）、属性定义（每个属性的取值和计算规则）、算法描述（如何计算布局）。属性定义表格是规范的核心部分，包含属性名、合法值、初始值、适用元素、是否继承、百分比如何计算、计算值如何得出。值定义语法用符号描述属性接受什么值（如 <length> | auto 表示长度或 auto 关键字）。规范区分「规范性」内容（必须实现）和「信息性」内容（示例、注释）。实用建议：从 MDN 等二手资料入手，遇到疑问再查规范；关注属性定义表格和值语法；浏览器行为与规范不符时，优先以规范为准判断是否为 bug。',
      en: 'CSS specifications are the authoritative definition of CSS, but are not beginner-friendly. The primary readers of specifications are browser developers and CSS authors. Learning to read specifications allows you to understand precise property behavior, resolve ambiguities in secondary materials, and anticipate browser differences. Specifications typically include: introduction sections (design philosophy), syntax definitions (how to parse), property definitions (valid values and computation rules for each property), and algorithm descriptions (how to calculate layout). Property definition tables are the core part of specifications, containing property name, legal values, initial value, applicable elements, whether inherited, how percentages are calculated, and how computed values are derived. Value definition syntax uses symbols to describe what values a property accepts (e.g., <length> | auto means a length or the auto keyword). Specifications distinguish between "normative" content (must be implemented) and "informative" content (examples, notes). Practical advice: start with secondary materials like MDN, consult specifications when in doubt; focus on property definition tables and value syntax; when browser behavior differs from specifications, prioritize the specification to determine if it is a bug.',
    },
    keyPoints: [
      '规范读者：浏览器开发者（实现）和 CSS 作者（理解精确行为）',
      '规范结构：介绍 → 语法定义 → 属性定义 → 算法描述 → 附录',
      '属性定义表格包含：Value（值语法）、Initial（初始值）、Applies to（适用元素）、Inherited（是否继承）、Percentages（百分比计算）、Computed value（计算值规则）',
      '值定义语法：<type>（数据类型）、|（选其一）、||（出现一个或多个）、&&（全部出现任意顺序）、?（可选）、*（0次或多次）',
      '规范性 vs 信息性：规范性内容是必须实现的行为，信息性内容是示例和解释',
      '实用建议：从 MDN 出发 → 遇到疑问查规范 → 关注属性定义表和值语法',
      'CSS2.2 属性定义在 §1.4.2 详细说明了表格各字段的含义',
    ],
    tutorial: [
      { type: 'heading', text: '为什么要学会读规范？' },
      { type: 'paragraph', text: 'CSS 规范是 CSS 的**权威定义**——MDN、博客、教程都是二手资料，可能过时或有误。当你遇到疑问时（「这个属性到底怎么计算？」「百分比相对于谁？」「这是浏览器 bug 还是我理解错了？」），规范是最终裁判。学会读规范能让你理解属性的精确行为、预判浏览器差异、解决二手资料的模糊性。规范主要面向两类读者：浏览器开发者（实现规范）和 CSS 作者（理解精确行为）。' },
      { type: 'heading', text: '属性定义表格：规范的核心' },
      { type: 'paragraph', text: '规范中最重要的部分是**属性定义表格**（property definition table）。每个属性都有一个表格，列出属性的所有关键信息。读懂这个表格，你就理解了 80% 的属性行为。' },
      { type: 'code', code: 'Name:          margin-top\nValue:         <length> | <percentage> | auto\nInitial:       0\nApplies to:    all elements except elements with table display types\nInherited:     no\nPercentages:   refer to width of containing block\nComputed value: the percentage or \'auto\' as specified or the absolute length', lang: 'text', caption: 'margin-top 的属性定义表格示例' },
      { type: 'paragraph', text: '这个表格告诉你：`margin-top` 接受长度、百分比或 `auto`；初始值是 `0`；适用于所有元素（表格类元素除外）；不继承；百分比相对于包含块的**宽度**（不是高度！）；计算值保留百分比或 `auto`，或转换为绝对长度。' },
      { type: 'heading', text: '值定义语法' },
      { type: 'paragraph', text: '属性定义表格中的 `Value` 字段用特殊语法描述属性接受什么值。理解这些符号是读规范的基础技能。' },
      { type: 'code', code: '/* 值语法符号说明 */\n<length>              // 数据类型（用尖括号）\n|                     // 选其一（OR）\n||                    // 一个或多个，任意顺序（AND）\n&&                    // 全部出现，任意顺序\n?                     // 可选（0 或 1 次）\n*                     // 0 次或多次\n+                     // 1 次或多次\n#                     // 1 次或多次，逗号分隔\n!                     // 至少出现一个（用于 ||）', lang: 'css', caption: '值定义语法符号表' },
      { type: 'example', title: '解析值语法', code: '<length> | auto', lang: 'text', explanation: '接受一个长度值（如 `10px`、`2em`）**或** `auto` 关键字，二者选其一。' },
      { type: 'example', title: '复杂语法示例', code: '<length>{1,4}', lang: 'text', explanation: '接受 1 到 4 个长度值（如 `margin: 10px 20px` 或 `margin: 10px 20px 30px 40px`）。' },
      { type: 'heading', text: '规范性 vs 信息性内容' },
      { type: 'paragraph', text: 'CSS 规范区分两种内容：**规范性**（normative）内容定义了必须实现的行为，**信息性**（informative）内容是示例、注释、解释。规范性内容是法律文本，信息性内容是辅助理解。规范中的示例通常标注为 "Example" 或放在绿色框中，这些是信息性内容——即使示例有错，也不影响规范本身。' },
      { type: 'tip', text: '规范的示例可能过时或有误——它们只是辅助理解，不是规范本身。如果示例与规范性文本冲突，以规范性文本为准。' },
      { type: 'heading', text: '实用阅读策略' },
      { type: 'list', ordered: true, items: [
        '**从 MDN 出发**：MDN 是最好的入门资料，语言友好、有实例、有浏览器兼容性',
        '**遇到疑问再查规范**：当 MDN 说得不够清楚、或你需要精确定义时，去查规范',
        '**直奔属性定义表**：打开规范后先找属性定义表格，读懂它就理解了 80%',
        '**关注值语法**：理解 `Value` 字段的符号，知道属性接受什么输入',
        '**看计算值规则**：`Computed value` 字段告诉你属性值如何从指定值转换为计算值',
        '**浏览器行为与规范不符时**：以规范为准判断是否为 bug，提交浏览器 bug 报告'
      ] },
      { type: 'tip', text: 'CSS2.2 规范的 §1.4.2 详细解释了属性定义表格的每个字段含义——强烈建议至少读一次。' },
      { type: 'warning', text: '规范不是教程——它是法律文本，优先精确性而非易读性。如果你是初学者，先从 MDN 学习，有经验后再读规范。' },
      { type: 'code', code: '// 实用技巧：用浏览器搜索快速定位\n// 打开规范页面后，按 Ctrl+F 搜索属性名\n// 大部分规范有锚点（如 #propdef-margin-top）\n// 可以直接在 URL 加锚点跳转', lang: 'javascript', caption: '快速定位规范内容' },
      { type: 'paragraph', text: '规范是你理解 CSS 的终极武器——它不会说谎，不会过时（模块化后更新很快），不会有浏览器差异（因为它定义了正确行为）。花时间学会读规范，你就获得了 CSS 的「源代码访问权」。' },
    ] as TutorialBlock[],
  },
  {
    id: 'core-terminology',
    number: '6',
    title: { zh: '核心术语', en: 'Core Terminology' },
    specId: 'defs',
    summary: {
      zh: 'CSS 有一套严谨的术语体系，理解这些术语是阅读规范的基础。属性（property）是 CSS 控制渲染的参数，如 color、margin。值（value）是属性被赋予的数据，如 red、10px。声明（declaration）是属性-值对，如 color: red。规则集（rule set）由选择器和声明块组成，如 h1 { color: red; }。样式表（style sheet）是一系列规则集和 at-rule 的集合。选择器（selector）定位文档树中的元素。元素（element）是文档的语法构成单元（如 HTML 的 <p>）。盒子（box）是 CSS 格式化模型中的渲染单元——一个元素可能生成零个、一个或多个盒子。替换元素（replaced element）的内容在 CSS 格式化模型之外（如 <img>、<video>），非替换元素的内容由 CSS 渲染（如 <p>、<div>）。文档树（document tree）是源文档解析后的元素层次结构。',
      en: 'CSS has a rigorous terminology system; understanding these terms is fundamental to reading specifications. A property is a parameter CSS uses to control rendering, such as color or margin. A value is the data assigned to a property, such as red or 10px. A declaration is a property-value pair, such as color: red. A rule set consists of a selector and a declaration block, such as h1 { color: red; }. A style sheet is a collection of rule sets and at-rules. A selector targets elements in the document tree. An element is a syntactic unit of a document (such as <p> in HTML). A box is a rendering unit in the CSS formatting model—an element may generate zero, one, or multiple boxes. A replaced element has content outside the CSS formatting model (such as <img>, <video>), while a non-replaced element has content rendered by CSS (such as <p>, <div>). The document tree is the hierarchical structure of elements after parsing the source document.',
    },
    keyPoints: [
      '属性（property）：CSS 的渲染参数，如 color、display、margin',
      '值（value）：属性被赋予的数据，如 red、block、10px',
      '声明（declaration）：属性: 值 对，如 color: red',
      '规则集（rule set）：选择器 + 声明块，如 h1 { color: red; margin: 0; }',
      '样式表（style sheet）：规则集和 at-rule 的集合',
      '选择器（selector）：定位元素的模式，如 h1、.class、#id、div > p',
      '元素（element）：文档的语法单元（HTML/XML 标签）',
      '盒子（box）：CSS 格式化模型的渲染单元，一个元素可能生成 0/1/多个盒子',
      '替换元素（replaced element）：内容在 CSS 之外，如 <img>、<video>、<iframe>',
      '非替换元素（non-replaced element）：内容由 CSS 渲染，如 <p>、<div>、<span>',
    ],
    tutorial: [
      { type: 'heading', text: '属性、值、声明' },
      { type: 'paragraph', text: 'CSS 的基本构成单元是**声明**（declaration），它由**属性**（property）和**值**（value）组成。属性是 CSS 定义的渲染参数（如 `color`、`margin`、`display`），值是你赋予属性的数据（如 `red`、`10px`、`block`）。属性和值用冒号分隔，声明用分号结尾。' },
      { type: 'code', code: 'color: red;       /* 声明 = 属性: 值; */\n/*  ↑     ↑\n    |     └─ 值（value）\n    └─ 属性（property）*/', lang: 'css', caption: '声明的解剖' },
      { type: 'heading', text: '规则集与样式表' },
      { type: 'paragraph', text: '多个声明可以组合成**声明块**（declaration block），用大括号包裹。**选择器**（selector）+ 声明块 = **规则集**（rule set，也叫 rule）。规则集定义了「对哪些元素应用哪些样式」。' },
      { type: 'code', code: 'h1 {                    /* ← 选择器 */\n  color: navy;          /* ← 声明 1 */\n  font-size: 2em;       /* ← 声明 2 */\n  margin: 1em 0;        /* ← 声明 3 */\n}                       /* ← 声明块用大括号包裹 */', lang: 'css', caption: '规则集 = 选择器 + 声明块' },
      { type: 'paragraph', text: '多个规则集和 at-rule（如 `@media`、`@import`）的集合构成**样式表**（style sheet）。样式表是 CSS 的最高层结构——一个 `.css` 文件就是一个样式表。' },
      { type: 'heading', text: '元素与盒子' },
      { type: 'paragraph', text: '这是 CSS 中最容易混淆的概念：**元素**（element）是文档的语法单元（如 HTML 的 `<p>`、`<div>`），**盒子**（box）是 CSS 格式化模型中的渲染单元。关键区别：**一个元素可能生成零个、一个或多个盒子**。' },
      { type: 'example', title: 'display: none 生成零个盒子', code: '<p style="display: none;">这段文字不可见</p>', lang: 'html', explanation: '元素存在于文档树中，但不生成盒子，完全不参与渲染和布局。' },
      { type: 'example', title: 'display: list-item 生成多个盒子', code: '<li>列表项</li>', lang: 'html', explanation: '`<li>` 元素生成两个盒子：主盒子（包含文本）和标记盒子（项目符号 •）。' },
      { type: 'warning', text: '元素 ≠ 盒子！读规范时要特别注意：「适用于所有元素」和「适用于所有盒子」是不同的概念。`display: none` 的元素仍然可以有 `color` 属性（虽然不渲染），因为属性应用于元素，而非盒子。' },
      { type: 'heading', text: '替换元素与非替换元素' },
      { type: 'paragraph', text: 'CSS 区分两类元素：**替换元素**（replaced element）的内容在 CSS 格式化模型**之外**，**非替换元素**（non-replaced element）的内容由 CSS 渲染。' },
      { type: 'list', items: [
        '**替换元素**：`<img>`（图片由解码器渲染）、`<video>`（视频播放器）、`<iframe>`（嵌入的文档）、`<input>`（表单控件由操作系统绘制）',
        '**非替换元素**：`<p>`、`<div>`、`<span>`、`<h1>`——内容是文本节点，由 CSS 控制字体、颜色、布局'
      ] },
      { type: 'tip', text: '替换元素通常有**固有尺寸**（intrinsic dimensions）——图片有原始像素尺寸，视频有分辨率。CSS 可以覆盖这些尺寸（`width: 100%`），但如果不设置，元素会使用固有尺寸。' },
      { type: 'code', code: '/* 替换元素示例 */\n<img src="photo.jpg" style="width: 200px;">  <!-- 原始尺寸 800×600，被缩放到 200px 宽 -->\n\n/* 非替换元素示例 */\n<p style="width: 200px;">这段文本的宽度由 CSS 控制</p>  <!-- 内容由 CSS 渲染 */', lang: 'html', caption: '替换元素 vs 非替换元素' },
      { type: 'heading', text: '文档树与格式化结构' },
      { type: 'paragraph', text: '**文档树**（document tree）是源文档解析后的元素层次结构——HTML 解析器将 `<html><body><p>...</p></body></html>` 转换为树形数据结构。**格式化结构**（formatting structure）是 CSS 生成的用于渲染的结构——它类似文档树，但可能不同。' },
      { type: 'code', code: '<!-- 文档树 -->\nhtml\n└─ body\n   └─ p (display: none)\n      └─ span\n\n<!-- 格式化结构（p 及其子元素不生成盒子）-->\nhtml\n└─ body\n   (p 和 span 不在格式化结构中)', lang: 'text', caption: 'display: none 导致文档树与格式化结构不同' },
      { type: 'example', title: '::before 伪元素', code: 'p::before {\n  content: "► ";\n}', lang: 'css', explanation: '`::before` 生成的内容只存在于格式化结构中，不存在于文档树中。JavaScript 的 DOM API 看不到伪元素。' },
      { type: 'warning', text: 'CSS **永远不会修改文档树**——生成内容、`display: none`、变换（transform）都只影响格式化结构和渲染，文档树保持不变。' },
      { type: 'list', items: [
        '**属性**是 CSS 的参数，**值**是数据，**声明**是属性-值对',
        '**规则集**由选择器和声明块组成，**样式表**是规则集的集合',
        '**元素**是文档的语法单元，**盒子**是渲染单元，两者不是一对一关系',
        '**替换元素**内容在 CSS 之外（如图片），**非替换元素**内容由 CSS 渲染',
        '**文档树**来自解析，**格式化结构**用于渲染，两者可能不同'
      ] },
      { type: 'tip', text: '这些术语是阅读 CSS 规范的基础——规范会大量使用这些词汇，理解它们能让你准确理解规范的意图。' },
    ] as TutorialBlock[],
  },
];

export const anchors: Record<string, string> = {
  // §1 css-overview
  'html-tutorial': 'css-overview',
  'xml-tutorial': 'css-overview',
  // §2 design-principles
  'design-principles': 'design-principles',
  // §3 processing-model
  'processing-model': 'processing-model',
  'the-canvas': 'processing-model',
  'canvas': 'processing-model',
  'addressing': 'processing-model',
  // §4 css-history
  'css2.2-v-css2': 'css-history',
  'q1.0': 'css-history',
  // §5 reading-specs
  'reading': 'reading-specs',
  'organization': 'reading-specs',
  'doc-language': 'reading-specs',
  'property-defs': 'reading-specs',
  'shorthand': 'reading-specs',
  'notes-and-examples': 'reading-specs',
  'images-and-longdesc': 'reading-specs',
  // §6 core-terminology
  'defs': 'core-terminology',
  'conformance': 'core-terminology',
  'doctree': 'core-terminology',
  'root': 'core-terminology',
  'errors': 'core-terminology',
  'text-css': 'core-terminology',
};

export const glossaryTerms: Record<string, GlossaryEntry> = {
  'style sheet': {
    zh: '样式表',
    description: '一组 CSS 规则的集合，用于指定文档的呈现方式。样式表可以来自作者、用户或用户代理。',
    sectionRef: 'intro#css-overview',
    css2Url: 'https://www.w3.org/TR/CSS22/conform.html#style-sheet',
  },
  'canvas': {
    zh: '画布',
    description: 'CSS 渲染的目标空间。Canvas 在每个维度上都是无限的，但渲染通常发生在有限区域内（如视口或页面）。',
    sectionRef: 'intro#processing-model',
    css2Url: 'https://www.w3.org/TR/CSS22/intro.html#the-canvas',
  },
  'document tree': {
    zh: '文档树',
    description: '源文档解析后的元素层次结构。文档树中的每个元素（除根元素外）有且仅有一个父元素。',
    sectionRef: 'intro#core-terminology',
    css2Url: 'https://www.w3.org/TR/CSS22/conform.html#doctree',
  },
  'element tree': {
    zh: '元素树',
    description: '文档树的同义词。强调树的节点是元素（element）。',
    sectionRef: 'intro#core-terminology',
  },
  'box tree': {
    zh: '盒子树',
    description: 'CSS 格式化模型生成的盒子层次结构。与文档树类似但可能不同——display: none 不生成盒子，::before 生成额外盒子。',
    sectionRef: 'intro#processing-model',
  },
  'formatting structure': {
    zh: '格式化结构',
    description: '从文档树生成的用于渲染的结构。可能包含比文档树更多或更少的信息（如生成内容、display: none）。',
    sectionRef: 'intro#processing-model',
    css2Url: 'https://www.w3.org/TR/CSS22/intro.html#processing-model',
  },
  'replaced element': {
    zh: '替换元素',
    description: '内容在 CSS 格式化模型之外的元素，如 <img>、<video>、<iframe>。通常有固有尺寸（intrinsic dimensions）。',
    sectionRef: 'intro#core-terminology',
    css2Url: 'https://www.w3.org/TR/CSS22/conform.html#replaced-element',
  },
  'non-replaced element': {
    zh: '非替换元素',
    description: '内容由 CSS 渲染的元素，如 <p>、<div>、<span>。内容是文档树的一部分。',
    sectionRef: 'intro#core-terminology',
  },
  'property': {
    zh: '属性',
    description: 'CSS 定义的用于控制渲染的参数，如 color、display、margin。每个属性有名称、值域和行为定义。',
    sectionRef: 'intro#core-terminology',
    css2Url: 'https://www.w3.org/TR/CSS22/conform.html#property',
  },
  'initial containing block': {
    zh: '初始包含块',
    description: '根元素的包含块，尺寸通常等于视口（屏幕）或页面（打印）。',
    sectionRef: 'intro#processing-model',
  },
  'author': {
    zh: '作者',
    description: '编写文档和样式表的人或工具。作者样式表通常通过 <link> 或 <style> 关联到文档。',
    sectionRef: 'intro#css-overview',
    css2Url: 'https://www.w3.org/TR/CSS22/conform.html#author',
  },
  'user': {
    zh: '用户',
    description: '浏览文档的人。用户可以提供个人样式表（user style sheet）来覆盖作者样式。',
    sectionRef: 'intro#css-overview',
    css2Url: 'https://www.w3.org/TR/CSS22/conform.html#user',
  },
  'user agent': {
    zh: '用户代理',
    description: '解释文档和样式表的程序，通常指浏览器。用户代理提供默认样式表（user agent style sheet）。',
    sectionRef: 'intro#css-overview',
    css2Url: 'https://www.w3.org/TR/CSS22/conform.html#user-agent',
  },
  'intrinsic dimensions': {
    zh: '固有尺寸',
    description: '元素自身定义的宽度、高度和宽高比（如图片的原始像素尺寸），不由 CSS 强加。',
    sectionRef: 'intro#core-terminology',
    css2Url: 'https://www.w3.org/TR/CSS22/conform.html#intrinsic',
  },
};
